#!/usr/bin/ruby

require 'digest/sha1'
require 'find'
require 'optparse'
require 'sqlite3'

#-------------------------------------------------------------------------------
# Class definitions

class Report
    attr_accessor :file_added, :file_updated, :file_removed
    attr_accessor :tape_added, :tape_updated, :tape_removed
    attr_accessor :tapeset_added, :tapeset_updated, :tapeset_removed
    attr_accessor :link_added, :link_updated, :link_removed

    def initialize()
        @file_added = 0
        @file_updated = 0
        @file_removed = 0

        @tape_added = 0
        @tape_updated = 0
        @tape_removed = 0

        @tapeset_added = 0
        @tapeset_updated = 0
        @tapeset_removed = 0

        @link_added = 0
        @link_updated = 0
        @link_removed = 0
    end

    def report()
        sum = 0
        sum += @file_added + @file_updated + @file_removed
        sum += @tape_added + @tape_updated + @tape_removed
        sum += @tapeset_added + @tapeset_updated + @tapeset_removed
        sum += @link_added + @link_updated + @link_removed
        puts("Report:")
        puts("  #{@file_added} file records added.") if @file_added > 0
        puts("  #{@file_updated} file records updated.") if @file_updated > 0
        puts("  #{@file_removed} file records removed.") if @file_removed > 0
        puts("  #{@tape_added} tape records added.") if @tape_added > 0
        puts("  #{@tape_updated} tape records updated.") if @tape_updated > 0
        puts("  #{@tape_removed} tape records removed.") if @tape_removed > 0
        puts("  #{@tapeset_added} tapeset records added.") if @tapeset_added > 0
        puts("  #{@tapeset_updated} tapeset records updated.") if @tapeset_updated > 0
        puts("  #{@tapeset_removed} tapeset records removed.") if @tapeset_removed > 0
        puts("  #{@link_added} file <-> tape link records added.") if @link_added > 0
        puts("  #{@link_updated} file <-> tape link records updated.") if @link_updated > 0
        puts("  #{@link_removed} file <-> tape link records removed.") if @link_removed > 0
        puts('  No database modifications.') if sum == 0
    end
end

class State
    attr_accessor :db, :version, :db_version, :report, :mode, :action
    attr_accessor :verbose, :quiet, :relative, :duplicates, :items, :incompatible

    def initialize()
        @db = nil
        @version = 1
        @db_version = 1
        @report = Report.new()
        @mode = ''
        @action = ''
        
        @verbose = false
        @quiet = false
        @relative = false
        @duplicates = false

        @items = []

        @incompatible = false
    end
end

#-------------------------------------------------------------------------------
# Global vars section

$state = State.new()

#-------------------------------------------------------------------------------
# DB method section

def db_empty?()
    db = $state.db

    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')

    version_table.length == 0
end

def db_create_version_table()
    db = $state.db

    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')

    db.execute("INSERT INTO version(version, db_version) VALUES(#{$state.version}, #{$state.db_version})")
end

def db_create_files_table()
    db = $state.db
    
	db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, 
        sha1 TEXT, size INTEGER, mtime INTEGER, path TEXT, latest INTEGER,
        deleted INTEGER)')

	db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
	db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY,
        label TEXT, size INTEGER, tapeset INTEGER, tapeset_idx INTEGER)')
end

def db_create_tapesets_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY,
        name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_file_tape_links_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS file_tape_links(file_number INTEGER, 
        tape_number INTEGER)')
end

def db_create_schema()
    unless ($state.quiet)
        puts('Initializing new database.')
    end
    db_create_version_table()
    db_create_files_table()
    db_create_tapes_table()
    db_create_tapesets_table()
    db_create_file_tape_links_table()
end

def db_increment_schema(current)
    db = $state.db

    unless ($state.quiet)
        puts("Updating database schema from V#{current}.")
    end

    if (current == 1)
        # TODO: Handle schema update from V1 to V2 here.
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1

    db.execute("UPDATE version SET db_version=#{current}")

    return current
end

def db_update_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != $state.version)
        db.execute("UPDATE version SET version=#{$state.version}")
    end

    while (db_version_in_db < $state.db_version)
        db_version_in_db = db_increment_schema(db_version_in_db)
    end
end

def db_check_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db > $state.version) || (db_version_in_db > $state.db_version)
        puts('Error: Database was created with higher code or database version of the tools.')
        $state.incompatible = true
        return
    end
    
    db_update_schema()
end

def db_init()
    db = SQLite3::Database.new("filetools.db")
    $state.db = db

    if (db_empty?)
        db_create_schema()
    else
        db_check_schema()
    end

    if ($state.incompatible)
        exit(-1)
    end

    unless ($state.quiet)
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM files').to_s + ' file records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapes').to_s + ' tape records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapesets').to_s + ' tape set records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM file_tape_links').to_s + ' file <-> tape link records in database.')
    end
end

#-------------------------------------------------------------------------------
# File method section

def file_sha1(absolute_path)
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    sha1.hexdigest()
end

def file_exists(file)
    if ($state.verbose)
        puts("File record for #{file} exists.")
    end
end

def file_doesnt_exist(file)
    unless ($state.quiet)
        puts("File record for #{file} does not exist.")
    end
end

def file_added(file)
    $state.report.file_added += 1
    if ($state.verbose)
        puts("File record for #{file} added.")
    end
end

def file_removed(file)
    $state.report.file_removed += 1
    if ($state.verbose)
        puts("File record for #{file} removed.")
    end
end

def file_updated(file)
    $state.report.file_updated += 1
    if ($state.verbose)
        puts("File record for #{file} updated.")
    end
end

#-------------------------------------------------------------------------------
# Path method section

#-------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if label.length != 8
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L4'
        size = 800000000000
    end
    return size
end

def tape_exists(label)
    if ($state.verbose)
        puts "Tape record for #{label} exists."
    end
end

def tape_added(label)
    $state.report.tape_added += 1
    if ($state.verbose)
        puts("Tape record for #{label} added.")
    end
end

#-------------------------------------------------------------------------------
# Tool method section

def tool_check_command_line(command_line)
    # If in tape mode, parse items array for possible input from barcode reader.
    if ($state.mode == 'tape')
        new_items = []
        $state.items.each() do |str|
            new_items << str.split('*').reject { |c| c.empty? }
        end
        new_items.flatten!.uniq!
        $state.items = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune write erase verify], \
        'path' => %w[manifest write erase verify], \
        'tape' => %w[update prune check], \
        'tapeset' => %w[update manifest prune check write erase verify] \
    }
    if (illegal[$state.mode] == nil)
        puts("Error: Unsupported mode #{$state.mode} specified.")
        return false
    elsif (illegal[$state.mode].include?($state.action))
        puts("Error: Mode #{$state.mode} cannot be combined with action #{$state.action}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check write erase verify]
    unless (legal.include?($state.action))
        puts("Error: Unsupported action #{$state.action} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = 0
    max = 0
    case $state.action
    when 'add', 'update', 'remove', 'info', 'prune', 'check'
        min = 1
        max = -1
    when 'list'
        min = 0
        max = -1
    when 'manifest', 'write', 'erase', 'verify'
        min = 1
        max = 1
    end
    if ($state.items.length() < min)
        puts("Error: At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && ($state.items.length() > max)
        puts("Error: Maximum #{max} items may be specified.")
        return false
    end

    # Check if all items are valid files if in file mode.
    if ($state.mode == 'file')
        $state.items.each() do |file|
            unless (File.file?(file))
                puts("Error: Incorrect file name: #{file}")
                return false
            end
        end
    end

    # Check if all items are valid paths if in path mode.
    if ($state.mode == 'path')
        $state.items.each() do |path|
            unless (File.directory?(path))
                puts("Error: Incorrect path name: #{path}")
                return false
            end
        end
    end

    # Check if all items are valid tapes if in tape mode.
    if ($state.mode == 'tape')
        $state.items.each() do |label|
            unless (tape_valid_label?(label))
                puts("Error: Incorrect tape label: #{label}")
                return false
            end
        end
    end

    # All is OK!
    return true
end

def tool_parse_command_line()
    parser = OptionParser.new() do |options|
        options.on('-h', '--help', 'Displays this help message.') do ||
            puts(options)
        end

        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            $state.mode = mode
        end

        options.on('-a', '--add item', 'Adds the specified item.') do |item|
            $state.action = 'add'
            $state.items << item
        end
        options.on('-u', '--update item', 'Updates the specified item.') do |item|
            $state.action = 'update'
            $state.items << item
        end
        options.on('-r', '--remove item', 'Removes the specified item.') do |item|
            $state.action = 'remove'
            $state.items << item
        end
        options.on('-l', '--list [item]', 'Lists the specified item.') do |item|
            $state.action = 'list'
            $state.items << item if item
        end
        options.on('-i', '--info item', 'Displays info about the specified item.') do |item|
            $state.action = 'info'
            $state.items << item
        end
        options.on('-M', '--manifest tape', 'Displays the manifest of the specified tape.') do |tape|
            $state.action = 'manifest'
            $state.items << item
        end
        options.on('-p', '--prune item', 'Prunes the specified item.') do |item|
            $state.action = 'prune'
            $state.items << item
        end
        options.on('-c', '--check item', 'Checks the specified item.') do |item|
            $state.action = 'check'
            $state.items << item
        end
        options.on('-w', '--write tape', 'Writes the specified tape.') do |tape|
            $state.action = 'write'
            $state.items << item
        end
        options.on('-e', '--erase tape', 'Erases the specified tape.') do |tape|
            $state.action = 'erase'
            $state.items << item
        end
        options.on('-V', '--verify tape', 'Verifies the specified tape.') do |tape|
            $state.action = 'verify'
            $state.items << item
        end

        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            $state.verbose = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            $state.quiet = true
            $state.verbose = false
        end
        options.on('-R', '--relative', 'Display paths as relative.') do ||
            $state.relative = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            $state.duplicates = true
        end
    end
    parser.parse!
    $state.items.flatten!
end

def tool_add_paths()
    db = $state.db
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
			    absolute_path = File.expand_path(path)
			    filesize = File.size(absolute_path)
			    mtime = File.mtime(absolute_path)

                present_in_db = db.get_first_value("SELECT COUNT(*) FROM files WHERE path=\"#{absolute_path}\" AND deleted=0").to_i()
                if (present_in_db == 0)
                    sha1 = file_sha1(absolute_path)
                    db.execute("INSERT INTO files (sha1, size, mtime, path, latest, deleted) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1, 0)")
                    file_added(absolute_path)
                else
                    file_exists(absolute_path)
                end
            end
        end
    end
end

def tool_update_paths()
    db = $state.db
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
			    absolute_path = File.expand_path(path)
			    filesize = File.size(absolute_path)
			    mtime = File.mtime(absolute_path)

                files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND latest=1 AND deleted=0")
                if (files.length() == 0)
                    file_doesnt_exist(absolute_path)
                elsif (files.length() == 1)
                    file = files[0]

                    unless ((file[2] == filesize) && (file[3] == mtime.to_i()))
                        sha1 = file_sha1(absolute_path)
                        file_num = file[0]
                        on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

                        if (on_tapes != 0)
                            db.execute("UPDATE files SET latest=0 WHERE number=#{file_num}")
                            db.execute("INSERT INTO files (sha1, size, mtime, path, latest, deleted) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1, 0)")
                            file_added(absolute_path)
                        else
                            db.execute("UPDATE files SET sha1=\"#{sha1}\", size=#{filesize}, mtime=#{mtime.to_i} WHERE number=#{file_num}")
                            file_updated(absolute_path)
                        end
                    end
                else
                    puts("Error: #{absolute_path} appears multiple times as latest file in database.")
                end
            end
        end
    end
end

def tool_remove_paths()
    db = $state.db
    $state.items.each() do |dir|
        Find.find(dir) do |path|
	        if File.file?(path)
		        absolute_path = File.expand_path(path)

                files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND latest=1 AND deleted=0")
                if (files.length() == 0)
                    file_doesnt_exist(absolute_path)
                elsif (files.length() == 1)
                    file = files[0]

                    file_num = file[0]
                    on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

                    if (on_tapes != 0)
                        db.execute("UPDATE files SET latest=0, deleted=1 WHERE number=#{file_num}")
                        file_updated(absolute_path)
                    else
                        db.execute("DELETE FROM files WHERE number=#{file_num}")
                        file_removed(absolute_path)
                    end
                else
                    puts("Error: #{absolute_path} appears multiple times as latest file in database.")
                end
            end
        end
    end
end

def tool_prune_paths()
end

def tool_add_tapes()
    db = $state.db
    $state.items.each() do |label|
        present_in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"").to_i()
        if (present_in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset, tapeset_idx) VALUES (\"#{label}\", #{size}, -1, -1)")
            tape_added(label)
        else
            tape_exists(label)
        end
    end
end

begin
    unless ($state.quiet)
        puts("Filetool (Version #{$state.version}, DB Version #{$state.db_version})")
    end

    error = !tool_check_command_line(tool_parse_command_line())
    unless (error)
        db_init()

        # TODO: Operational logic of the tool goes here.

        # Handle path mode.
        if ($state.mode == 'path')
            case $state.action
            when 'add'
                tool_add_paths()
            when 'update'
                tool_update_paths()
            when 'remove'
                tool_remove_paths()
            when 'prune'
                tool_prune_paths()
            end
        end

        if ($state.mode == 'tape') && ($state.action == 'add')
            tool_add_tapes()
        end        

        unless ($state.quiet)
            $state.report.report()
        end
    end
rescue SQLite3::Exception => e 
    puts "Database exception occurred:"
    puts e
ensure
    db = $state.db
    db.close if db
end

