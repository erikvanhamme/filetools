#!/usr/bin/ruby

require 'optparse'

#-------------------------------------------------------------------------------
# Class definitions

class Report
    attr_accessor :file_added, :file_updated, :file_removed
    attr_accessor :tape_added, :tape_updated, :tape_removed
    attr_accessor :tapeset_added, :tapeset_updated, :tapeset_removed
    attr_accessor :link_added, :link_updated, :link_removed

    def initialize()
        @file_added = 0
        @file_updated = 0
        @file_removed = 0

        @tape_added = 0
        @tape_updated = 0
        @tape_removed = 0

        @tapeset_added = 0
        @tapeset_updated = 0
        @tapeset_removed = 0

        @link_added = 0
        @link_updated = 0
        @link_removed = 0
    end

    def report()
        sum = 0
        sum += @file_added + @file_updated + @file_removed
        sum += @tape_added + @tape_updated + @tape_removed
        sum += @tapeset_added + @tapeset_updated + @tapeset_removed
        sum += @link_added + @link_updated + @link_removed
        puts("Report:")
        puts("  #{@file_added} file records added.") if @file_added > 0
        puts("  #{@file_updated} file records updated.") if @file_updated > 0
        puts("  #{@file_removed} file records removed.") if @file_removed > 0
        puts("  #{@tape_added} tape records added.") if @tape_added > 0
        puts("  #{@tape_updated} tape records updated.") if @tape_updated > 0
        puts("  #{@tape_removed} tape records removed.") if @tape_removed > 0
        puts("  #{@tapeset_added} tapeset records added.") if @tapeset_added > 0
        puts("  #{@tapeset_updated} tapeset records updated.") if @tapeset_updated > 0
        puts("  #{@tapeset_removed} tapeset records removed.") if @tapeset_removed > 0
        puts("  #{@link_added} file <-> tape link records added.") if @link_added > 0
        puts("  #{@link_updated} file <-> tape link records updated.") if @link_updated > 0
        puts("  #{@link_removed} file <-> tape link records removed.") if @link_removed > 0
        puts('  No database modifications.') if sum == 0
    end
end

class State
    attr_accessor :db, :version, :db_version, :report, :mode, :action
    attr_accessor :verbose, :quiet, :relative, :duplicates
    attr_accessor :items

    def initialize()
        @db = nil
        @version = 1
        @db_version = 1
        @report = Report.new()
        @mode = ''
        @action = ''
        
        @verbose = false
        @quiet = false
        @relative = false
        @duplicates = false

        @items = []
    end
end

#-------------------------------------------------------------------------------
# Global vars section

$state = State.new()

#-------------------------------------------------------------------------------
# DB method section

#-------------------------------------------------------------------------------
# File method section

#-------------------------------------------------------------------------------
# Path method section

#-------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if label.length != 8
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

#-------------------------------------------------------------------------------
# Tool method section

def tool_check_command_line(command_line)
    # If in tape mode, parse items array for possible input from barcode reader.
    if ($state.mode == 'tape')
        new_items = []
        $state.items.each() do |str|
            new_items << str.split('*').reject { |c| c.empty? }
        end
        new_items.flatten!.uniq!
        $state.items = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune write erase verify], \
        'path' => %w[manifest write erase verify], \
        'tape' => %w[update prune check], \
        'tapeset' => %w[update manifest prune check write erase verify] \
    }
    if (illegal[$state.mode] == nil)
        puts("Error: Unsupported mode #{$state.mode} specified.")
        return false
    elsif (illegal[$state.mode].include?($state.action))
        puts("Error: Mode #{$state.mode} cannot be combined with action #{$state.action}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check write erase verify]
    unless (legal.include?($state.action))
        puts("Error: Unsupported action #{$state.action} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = 0
    max = 0
    case $state.action
    when 'add', 'update', 'remove', 'info', 'prune', 'check'
        min = 1
        max = -1
    when 'list'
        min = 0
        max = -1
    when 'manifest', 'write', 'erase', 'verify'
        min = 1
        max = 1
    end
    if ($state.items.length() < min)
        puts("Error: At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && ($state.items.length() > max)
        puts("Error: Maximum #{max} items may be specified.")
        return false
    end

    # Check if all items are valid files if in file mode.
    if ($state.mode == 'file')
        $state.items.each() do |file|
            unless (File.file?(file))
                puts("Error: Incorrect file name: #{file}")
                return false
            end
        end
    end

    # Check if all items are valid paths if in path mode.
    if ($state.mode == 'path')
        $state.items.each() do |path|
            unless (File.directory?(path))
                puts("Error: Incorrect path name: #{path}")
                return false
            end
        end
    end

    # Check if all items are valid tapes if in tape mode.
    if ($state.mode == 'tape')
        $state.items.each() do |label|
            unless (tape_valid_label?(label))
                puts("Error: Incorrect tape label: #{label}")
                return false
            end
        end
    end

    # All is OK!
    return true
end

def tool_parse_command_line()
    parser = OptionParser.new() do |options|
        options.on('-h', '--help', 'Displays this help message.') do ||
            puts(options)
        end

        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            $state.mode = mode
        end

        options.on('-a', '--add item', 'Adds the specified item.') do |item|
            $state.action = 'add'
            $state.items << item
        end
        options.on('-u', '--update item', 'Updates the specified item.') do |item|
            $state.action = 'update'
            $state.items << item
        end
        options.on('-r', '--remove item', 'Removes the specified item.') do |item|
            $state.action = 'remove'
            $state.items << item
        end
        options.on('-l', '--list [item]', 'Lists the specified item.') do |item|
            $state.action = 'list'
            $state.items << item if item
        end
        options.on('-i', '--info item', 'Displays info about the specified item.') do |item|
            $state.action = 'info'
            $state.items << item
        end
        options.on('-M', '--manifest tape', 'Displays the manifest of the specified tape.') do |tape|
            $state.action = 'manifest'
            $state.items << item
        end
        options.on('-p', '--prune item', 'Prunes the specified item.') do |item|
            $state.action = 'prune'
            $state.items << item
        end
        options.on('-c', '--check item', 'Checks the specified item.') do |item|
            $state.action = 'check'
            $state.items << item
        end
        options.on('-w', '--write tape', 'Writes the specified tape.') do |tape|
            $state.action = 'write'
            $state.items << item
        end
        options.on('-e', '--erase tape', 'Erases the specified tape.') do |tape|
            $state.action = 'erase'
            $state.items << item
        end
        options.on('-V', '--verify tape', 'Verifies the specified tape.') do |tape|
            $state.action = 'verify'
            $state.items << item
        end

        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            $state.verbose = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            $state.quiet = true
            $state.verbose = false
        end
        options.on('-R', '--relative', 'Display paths as relative.') do ||
            $state.relative = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            $state.duplicates = true
        end
    end
    parser.parse!
    $state.items.flatten!
end

error = !tool_check_command_line(tool_parse_command_line())
puts error
puts $state.items

