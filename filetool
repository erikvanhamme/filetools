#!/usr/bin/ruby

# Copyright 2018 Erik Van Hamme
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'digest/sha1'
require 'fileutils'
require 'find'
require 'optparse'
require 'pathname'
require 'sqlite3'
require 'table_print'

#-------------------------------------------------------------------------------
# Class definitions

class Report
    attr_accessor :file_added, :file_updated, :file_removed
    attr_accessor :tape_added, :tape_updated, :tape_removed
    attr_accessor :tapeset_added, :tapeset_updated, :tapeset_removed
    attr_accessor :link_added, :link_updated, :link_removed

    def initialize()
        @file_added = 0
        @file_updated = 0
        @file_removed = 0

        @tape_added = 0
        @tape_updated = 0
        @tape_removed = 0

        @tapeset_added = 0
        @tapeset_updated = 0
        @tapeset_removed = 0

        @link_added = 0
        @link_updated = 0
        @link_removed = 0
    end

    def report()
        sum = 0
        sum += @file_added + @file_updated + @file_removed
        sum += @tape_added + @tape_updated + @tape_removed
        sum += @tapeset_added + @tapeset_updated + @tapeset_removed
        sum += @link_added + @link_updated + @link_removed
        puts("Report:")
        puts("  #{@file_added} file records added.") if @file_added > 0
        puts("  #{@file_updated} file records updated.") if @file_updated > 0
        puts("  #{@file_removed} file records removed.") if @file_removed > 0
        puts("  #{@tape_added} tape records added.") if @tape_added > 0
        puts("  #{@tape_updated} tape records updated.") if @tape_updated > 0
        puts("  #{@tape_removed} tape records removed.") if @tape_removed > 0
        puts("  #{@tapeset_added} tapeset records added.") if @tapeset_added > 0
        puts("  #{@tapeset_updated} tapeset records updated.") if @tapeset_updated > 0
        puts("  #{@tapeset_removed} tapeset records removed.") if @tapeset_removed > 0
        puts("  #{@link_added} file <-> tape link records added.") if @link_added > 0
        puts("  #{@link_updated} file <-> tape link records updated.") if @link_updated > 0
        puts("  #{@link_removed} file <-> tape link records removed.") if @link_removed > 0
        puts('  No database modifications.') if sum == 0
    end
end

class State
    attr_accessor :db, :version, :db_version, :report, :mode, :action
    attr_accessor :verbose, :quiet, :relative, :duplicates, :items, :incompatible 
    attr_accessor :double, :triple, :name, :ffd, :async, :device

    def initialize()
        @db = nil
        @version = 1
        @db_version = 1
        @report = Report.new()
        @mode = ''
        @action = ''
        
        @verbose = false
        @quiet = false
        @relative = false
        @duplicates = false

        @items = []

        @incompatible = false

        @double = false
        @triple = false
        @ffd = false
        @async = false

        @name = ''
        @device = ''
    end
end

#-------------------------------------------------------------------------------
# Global vars section

$state = State.new()

#-------------------------------------------------------------------------------
# DB method section

def db_empty?()
    db = $state.db

    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')

    version_table.length == 0
end

def db_create_version_table()
    db = $state.db

    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')

    db.execute("INSERT INTO version(version, db_version) VALUES(#{$state.version}, #{$state.db_version})")
end

def db_create_files_table()
    db = $state.db
    
	db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, 
        sha1 TEXT, size INTEGER, mtime INTEGER, path TEXT, on_disk INTEGER)')

	db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
	db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY,
        label TEXT, size INTEGER, tapeset INTEGER, tapeset_idx INTEGER)')
end

def db_create_tapesets_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY,
        name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_file_tape_links_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS file_tape_links(file_number INTEGER, 
        tape_number INTEGER)')
end

def db_create_schema()
    unless ($state.quiet)
        puts('Initializing new database.')
    end
    db_create_version_table()
    db_create_files_table()
    db_create_tapes_table()
    db_create_tapesets_table()
    db_create_file_tape_links_table()
end

def db_increment_schema(current)
    db = $state.db

    unless ($state.quiet)
        puts("Updating database schema from V#{current}.")
    end

    if (current == 1)
        # TODO: Handle schema update from V1 to V2 here.
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1

    db.execute("UPDATE version SET db_version=#{current}")

    return current
end

def db_update_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != $state.version)
        db.execute("UPDATE version SET version=#{$state.version}")
    end

    while (db_version_in_db < $state.db_version)
        db_version_in_db = db_increment_schema(db_version_in_db)
    end
end

def db_check_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db > $state.version) || (db_version_in_db > $state.db_version)
        puts('Error: Database was created with higher code or database version of the tools.')
        $state.incompatible = true
        return
    end
    
    db_update_schema()
end

def db_init()
    db = SQLite3::Database.new("filetool.db")
    $state.db = db

    if ($state.async)
        db.execute('PRAGMA synchronous = OFF')
    end

    if (db_empty?)
        db_create_schema()
    else
        db_check_schema()
    end

    if ($state.incompatible)
        exit(-1)
    end

    unless ($state.quiet)
        if ($state.async)
            puts('  Database in asynchronous mode.')
        end
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM files').to_s + ' file records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapes').to_s + ' tape records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapesets').to_s + ' tape set records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM file_tape_links').to_s + ' file <-> tape link records in database.')
    end
end

#-------------------------------------------------------------------------------
# File method section

def file_sha1(absolute_path)
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    sha1.hexdigest()
end

def file_exists(file, error = false)
    if ($state.verbose)
        e = error ? 'Error: ' : ''
        puts("#{e}File record for #{file} exists.")
    end
end

def file_doesnt_exist(file, error = false)
    unless ($state.quiet)
        e = error ? 'Error: ' : ''
        puts("#{e}File record for #{file} does not exist.")
    end
end

def file_added(file)
    $state.report.file_added += 1
    if ($state.verbose)
        puts("File record for #{file} added.")
    end
end

def file_removed(file)
    $state.report.file_removed += 1
    if ($state.verbose)
        puts("File record for #{file} removed.")
    end
end

def file_updated(file)
    $state.report.file_updated += 1
    if ($state.verbose)
        puts("File record for #{file} updated.")
    end
end

def file_add(file)
    db = $state.db
    absolute_path = File.expand_path(file)
    filesize = File.size(absolute_path)
    mtime = File.mtime(absolute_path)

    present_in_db = db.get_first_value("SELECT COUNT(*) FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1").to_i()
    if (present_in_db == 0)
        sha1 = file_sha1(absolute_path)
        db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
        file_added(absolute_path)
    else
        file_exists(absolute_path)
    end
end

def file_update(file)
    db = $state.db
    absolute_path = File.expand_path(file)
    filesize = File.size(absolute_path)
    mtime = File.mtime(absolute_path)

    files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
    if (files.length() == 0)
        file_doesnt_exist(absolute_path)
    elsif (files.length() == 1)
        file = files[0]

        unless ((file[2] == filesize) && (file[3] == mtime.to_i()))
            sha1 = file_sha1(absolute_path)
            file_num = file[0]
            on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

            if (on_tapes != 0)
                db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_num}")
                file_updated(absolute_path)
                db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
                file_added(absolute_path)
            else
                db.execute("UPDATE files SET sha1=\"#{sha1}\", size=#{filesize}, mtime=#{mtime.to_i} WHERE number=#{file_num}")
                file_updated(absolute_path)
            end
        end
    else
        puts("Error: #{absolute_path} appears multiple times as latest file in database.")
    end
end

def file_remove(file)
    db = $state.db
    absolute_path = File.expand_path(file)

    files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
    if (files.length() == 0)
        file_doesnt_exist(absolute_path)
    elsif (files.length() == 1)
        file = files[0]

        file_num = file[0]
        on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

        if (on_tapes != 0)
            db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_num}")
            file_updated(absolute_path)
        else
            db.execute("DELETE FROM files WHERE number=#{file_num}")
            file_removed(absolute_path)
        end
    else
        puts("Error: #{absolute_path} appears multiple times as latest file in database.")
    end
end

#-------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if label.length != 8
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L4'
        size = 800000000000
    end
    return size
end

def tape_exists(label, error = false)
    if ($state.verbose)
        e = error ? 'Error: ' : ''
        puts "#{e}Tape record for #{label} exists."
    end
end

def tape_doesnt_exist(label, error = false)
    unless ($state.quiet)
        e = error ? 'Error: ' : ''
        puts("#{e}Tape record for #{label} does not exist.")
    end
end

def tape_added(label)
    $state.report.tape_added += 1
    if ($state.verbose)
        puts("Tape record for #{label} added.")
    end
end

def tape_removed(label)
    $state.report.tape_removed += 1
    if ($state.verbose)
        puts("Tape record for #{label} removed.")
    end
end

def tape_updated(label)
    $state.report.tape_updated += 1
    if ($state.verbose)
        puts "Tape record for #{label} updated."
    end
end

def tapeset_added(name)
    $state.report.tapeset_added += 1
    if ($state.verbose)
        puts "Tapeset record for #{name} added."
    end
end

def tapeset_updated(name)
    $state.report.tapeset_updated += 1
    if ($state.verbose)
        puts "Tapeset record for #{name} updated."
    end
end

def tapeset_removed(name)
    $state.report.tapeset_removed += 1
    if ($state.verbose)
        puts "Tapeset record for #{name} removed."
    end
end

def tapeset_exists(name, error = false)
    if ($state.verbose || error)
        e = error ? 'Error: ' : ''
        puts "#{e}Tapeset record for #{name} exists." 
    end
end

def tapeset_doesnt_exist(name, error = false)
    if ($state.verbose || error)
        e = error ? 'Error: ' : ''
        puts("#{e}Tapeset record for #{name} doesnt exist.")
    end
end

def file_tape_link_added(name, label)
    $state.report.link_added += 1
    if ($state.verbose)
        puts "File <-> tape link record for #{name}, #{label} added."
    end
end

def file_tape_link_removed(name, label)
    $state.report.link_removed += 1
    if ($state.verbose)
        puts "File <-> tape link record for #{name}, #{label} removed."
    end
end

#-------------------------------------------------------------------------------
# Tool method section

def tool_check_command_line(command_line)
    # If in tape mode, parse items array for possible input from barcode reader.
    if ($state.mode == 'tape')
        new_items = []
        $state.items.each() do |str|
            new_items << str.split('*').reject() do |c| c.empty?() end
        end
        new_items.flatten!()
        unless (new_items == nil)
            new_items.uniq!()
        end
        $state.items = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune write erase verify], \
        'path' => %w[manifest write erase verify], \
        'tape' => %w[update prune check], \
        'tapeset' => %w[manifest prune check write erase verify] \
    }
    if (illegal[$state.mode] == nil)
        puts("Error: Unsupported mode #{$state.mode} specified.")
        return false
    elsif (illegal[$state.mode].include?($state.action))
        puts("Error: Mode #{$state.mode} cannot be combined with action #{$state.action}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check write erase verify]
    unless (legal.include?($state.action))
        puts("Error: Unsupported action #{$state.action} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = 0
    max = 0
    case $state.action
    when 'add', 'update', 'remove', 'prune', 'check'
        min = 1
        max = -1
        if (($state.mode == 'tapeset') && ($state.action == 'update'))
            max = 1
        end
    when 'list', 'info'
        min = 0
        max = -1
    when 'manifest', 'write', 'erase', 'verify'
        min = 1
        max = 1
    end
    if ($state.items.length() < min)
        puts("Error: At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && ($state.items.length() > max)
        puts("Error: Maximum #{max} items may be specified.")
        return false
    end

    # Items do not need to be checked when running list action (fuzzy input allowed.)
    unless($state.action == 'list')
        # Check if all items are valid files if in file mode.
        if ($state.mode == 'file')
            $state.items.each() do |file|
                unless (File.file?(file))
                    puts("Error: Incorrect file name: #{file}")
                    return false
                end
            end
        end

        # Check if all items are valid paths if in path mode. (or when adding in tapeset mode.)
        if (($state.mode == 'path') || (($state.mode == 'tapeset') && ($state.action == 'add')))
            $state.items.each() do |path|
                unless (File.directory?(path))
                    puts("Error: Incorrect path name: #{path}")
                    return false
                end
            end
        end

        # Check if all items are valid tapes if in tape mode, except when in list action.
        if ($state.mode == 'tape')
            $state.items.each() do |label|
                unless (tape_valid_label?(label))
                    puts("Error: Incorrect tape label: #{label}")
                    return false
                end
            end
        end
    end

    # Check if device is set properly when in tape mode and write, erase or verify is selected.
    actions = %w[write erase verify]
    if (($state.mode == 'tape') && (actions.include?($state.action)))
        unless (File.writable?($state.device))
            puts ("Error: No tape streamer device specified.")
            return false
        end
    end

    # All is OK!
    return true
end

def tool_parse_command_line()
    parser = OptionParser.new() do |options|
        options.separator('')
        options.separator('Mode:')

        # Mode handling.
        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            $state.mode = mode
        end

        options.separator('')
        options.separator('Modifiers:')

        # Modifiers handling.
        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            $state.verbose = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            $state.quiet = true
            $state.verbose = false
        end
        options.on('-R', '--relative', 'Use relative paths in manifest.') do ||
            $state.relative = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            $state.duplicates = true
        end
        options.on('-2', '--double', 'Enables double mode. Generates 2 tapesets.') do ||
            $state.double = true
        end
        options.on('-3', '--triple', 'Enables triple mode. Generates 3 tapesets.') do ||
            $state.triple = true
            $state.double = false
        end
        options.on('-D', '--first-fit-decreasing', 'Use First Fit Decreasing algorithm for packing files onto tapes.') do ||
            $state.ffd = true
        end
        options.on('-n', '--name name', 'Supplies the name of the tapeset.') do |name|
            $state.name = name
        end
        options.on('-A', '--async', 'Runs database in asynchronous mode. WARNING unsafe if PC crashes or loses power!') do ||
            $state.async = true
        end
        options.on('-t', '--tape-device device', 'Selects the tape device for tape operations.') do |device|
            $state.device = device
        end

        options.separator('')
        options.separator('Actions:')

        # Actions handling.
        options.on('-a', '--add', 'Adds the specified item.') do ||
            $state.action = 'add'
        end
        options.on('-u', '--update', 'Updates the specified item.') do ||
            $state.action = 'update'
        end
        options.on('-r', '--remove', 'Removes the specified item.') do ||
            $state.action = 'remove'
        end
        options.on('-l', '--list', 'Lists the specified item.') do ||
            $state.action = 'list'
        end
        options.on('-i', '--info', 'Displays info about the specified item.') do ||
            $state.action = 'info'
        end
        options.on('-M', '--manifest', 'Displays the manifest of the specified tape.') do ||
            $state.action = 'manifest'
        end
        options.on('-p', '--prune', 'Prunes the specified item.') do ||
            $state.action = 'prune'
        end
        options.on('-c', '--check', 'Checks the specified item.') do ||
            $state.action = 'check'
        end
        options.on('-w', '--write-scripts', 'Creates the write scripts for the tape.') do ||
            $state.action = 'write'
        end
        options.on('-e', '--erase-scripts', 'Creates the erase scripts for the tape.') do ||
            $state.action = 'erase'
        end
        options.on('-V', '--verify-scripts', 'Creates the verify scripts for the tape.') do ||
            $state.action = 'verify'
        end

        options.separator('')
        options.separator('Usage:')

        # Show usage if no options specified.
        options.on_tail('-h', '--help', 'Displays this help message.') do || 
            puts(options) 
        end
    end
    parser.parse!

    # What is left over at this point are the items (if any).
    $state.items = ARGV
end

def tool_add_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_add(file)
        end
    end
end

def tool_update_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_update(file)
        end
    end
end

def tool_remove_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_remove(file)
        end
    end
end

def tool_add_paths()
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
                file_add(path)
            end
        end
    end
end

def tool_update_paths()
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
                file_update(path)
            end
        end
    end
end

def tool_remove_paths()
    $state.items.each() do |dir|
        Find.find(dir) do |path|
	        if File.file?(path)
                file_remove(path)
            end
        end
    end
end

def tool_prune_paths()
    db = $state.db
    $state.items.each() do |path|
        absolute_path = File.expand_path(path)
        files = db.execute("SELECT number, path FROM files WHERE path LIKE \"#{absolute_path}%\" AND on_disk=1")
        files.each() do |file|
            unless (File.file?(file[1]))
                on_tape = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file[0]}").to_i()
                if (on_tape > 0)
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file[0]}")
                    file_updated(file[1])
                else
                    db.execute("DELETE FROM files WHERE number=#{file[0]}")
                    file_removed(file[1])
                end
            end
        end
    end
end

def tool_add_tapes()
    db = $state.db
    $state.items.each() do |label|
        present_in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"").to_i()
        if (present_in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset, tapeset_idx) VALUES (\"#{label}\", #{size}, -1, -1)")
            tape_added(label)
        else
            tape_exists(label)
        end
    end
end

def tool_remove_tapes()
    db = $state.db
    $state.items.each() do |label|
        tapes = db.execute("SELECT tapeset FROM tapes WHERE label=\"#{label}\"")
        if (tapes.length() > 0)
            if (tapes[0][0] != -1)
                tapeset = db.get_first_value("SELECT name FROM tapesets WHERE number=#{tapes[0][0]}")
                puts("Error: Cannot remove tape #{label} because it is part of tapeset: #{tapeset}.")
            else
                db.execute("DELETE FROM tapes WHERE label=\"#{label}\"")
                tape_removed(label)
            end
        else
            tape_doesnt_exist(label)
        end
    end
end

def tool_list_tapes()
    db = $state.db
    query = 'SELECT label FROM tapes'
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |label|
            query += " label LIKE \"%#{label}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'
    tapes = db.execute(query)
    tapes.collect!() do |tape|
        {:label => tape[0]}
    end
    tp(tapes, :label)
end

def tool_info_tapes()
    db = $state.db
    query = 'SELECT tapes.number, tapes.label, tapes.size, tapes.tapeset_idx, tapesets.name FROM tapes LEFT JOIN tapesets ON tapesets.number = tapes.tapeset' 
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |label|
            query += " tapes.label = \"#{label}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'

    tapes = db.execute(query)
    tapes.collect!() do |tape|
        query = "SELECT * FROM file_tape_links LEFT JOIN files ON file_tape_links.file_number = files.number WHERE file_tape_links.tape_number=#{tape[0]}"
        files = db.execute(query)

        size = 0
        files.each() do |file|
            size += file[4]
        end

        used = (size.to_f() / (tape[2].to_f() * 0.95)) * 100

        {:label => tape[1], :files => files.length(), :size => size, :capacity => tape[2], :usage => "#{used.round(1)} %", :tapeset_idx => tape[3], :tapeset => tape[4]}
    end
    tp(tapes, :label, :files, :size, :capacity, :usage, :tapeset_idx, :tapeset)
end

def tool_manifest_tapes()
    tape_label = $state.items[0]
    unless ($state.quiet)
        puts("File manifest for tape #{tape_label}:")
    end

    db = $state.db
    files = db.execute("SELECT path, sha1 FROM files LEFT JOIN file_tape_links ON file_tape_links.file_number = files.number LEFT JOIN tapes ON tapes.number = file_tape_links.tape_number WHERE tapes.label=\"#{tape_label}\" ORDER BY files.path ASC")

    files.each() do |file|
        filename = file[0]
        filename = Pathname.new(file[0]).relative_path_from(Pathname.new(File.expand_path(File.dirname(__FILE__)))).to_s() if ($state.relative)
        puts("#{file[1]}  #{filename}")
    end
end    

def tool_write_tapes()
    label = $state.items[0]
    puts("Writing tape #{label}")

    # Get the file data of the involved files.
    db = $state.db
    all_files = db.execute("SELECT path, sha1, on_disk FROM files LEFT JOIN file_tape_links ON file_tape_links.file_number = files.number LEFT JOIN tapes ON tapes.number = file_tape_links.tape_number WHERE tapes.label=\"#{label}\" ORDER BY files.path ASC")
    
    # Warn if files are no longer on disk. Could be that the tapeset was created long ago and is being re-written after some files have been removed. In this case we will exclude them from the tape. Exclude these from the write list at this point.
    write_files = []
    all_files.each() do |file|
        if (file[2] == 0)
            puts("Warning: File #{file[0]} is no longer on disk, writing the tape without it.")
        else
            write_files << file
        end
    end

    begin
        # Start by writing the manifest, checksums and filelist files.
        manifest_file = File.open('manifest.txt', 'w')
        checksums_file = File.open('checksums.txt', 'w')
        filelist_file = File.open('filelist.txt', 'w')

        filelist_file.puts('manifest.txt')
        filelist_file.puts('checksums.txt')

        write_files.each() do |file|
            relative_path = Pathname.new(file[0]).relative_path_from(Pathname.new(File.expand_path(File.dirname(__FILE__)))).to_s()

            manifest_file.puts(relative_path)
            filelist_file.puts(relative_path)
            checksums_file.puts("#{file[1]}  #{relative_path}")
        end

        # Then produce actual write script.
        script_file = File.open('write.sh', 'w')
        script_file.puts('#!/bin/bash')
        script_file.puts("echo \"Writing tape #{label}.\"")
        script_file.puts("mt-st -f #{$state.device} compression 0")
        if ($state.verbose)
            script_file.puts("tar -c -v -f #{$state.device} -b 8192 -T filelist.txt")
        else
            script_file.puts("tar -c -f #{$state.device} -b 8192 -T filelist.txt")
        end
        script_file.puts("mt-st -f #{$state.device} rewoffl")
        script_file.puts("echo \"Done.\"")
        
        FileUtils.chmod('u+x', 'write.sh')
    rescue IOError => e
        puts('IOError:')
        puts(e)
        error = true
    ensure
        manifest_file.close() unless manifest_file.nil?
        checksums_file.close() unless checksums_file.nil?
        filelist_file.close() unless filelist_file.nil?
        script_file.close() unless script_file.nil?
    end
end

def tool_add_tapesets()
    db = $state.db

    error = false
    files = nil
    set_count = 1
    tapeset_names = []
    
    # Handle command line settings from state.
    unless (error)
        if ($state.name.length() == 0)
            tapeset_names << 'tapeset'
        else
            tapeset_names << $state.name
        end
        set_count = 2 if ($state.double)
        set_count = 3 if ($state.triple)
        if (set_count > 1)
            n = tapeset_names[0]
            tapeset_names = []
            for i in 0..(set_count - 1)
                suffix = ''
                case i
                when 0
                    suffix = ' (primary)'
                when 1
                    suffix = ' (secondary)'
                when 2
                    suffix = ' (tertiary)'
                end
                tapeset_names << (n + suffix)
            end
        end
        tapeset_names.each() do |n|
            # Check if the name already exists in the tapesets table.
            c = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{n}\"").to_i()
            if (c > 0)
                tapeset_exists(n, true)
                error = true
            end
        end
    end

    # Command line settings alright? -> Proceed file selection from database.
    unless (error)
        accumulator = 0

        # Build the selection query.
        query = 'SELECT * FROM files WHERE ('
        $state.items.each() do |item|
            query += "path LIKE \"#{item}%\" OR "
        end
        query.chomp!(' OR ')
        query += ') AND (on_disk=1)'
        if ($state.ffd)
            query += ' ORDER BY size DESC'
        else
            query += ' ORDER BY path ASC'
        end
        files = db.execute(query)
        if (files.length() == 0)
            puts("Error: No files matched the selection criteria.")
            error = true
        end
    end

    # File selection alright? -> Proceed to bin packing of the tapes.
    unless (error)
        files.each() do |file|
            accumulator += file[2]
        end
        average_size = accumulator / files.length()

        # TODO: This is bad, find a way to deal with tapes of different sizes.
        first_tape_size = db.get_first_value('SELECT size FROM tapes')

        # Reduce tape size with 5% to make room for TAR blocking overhead.
        first_tape_size = (0.95 * first_tape_size).to_i()

        # Get smallest integer number of tapes that will fit the data.
        tapes_needed = (accumulator.to_f() / first_tape_size).ceil()

        # Add the average file size here to give the bin packing algorithm some wriggle room.
        bytes_per_tape = (accumulator / tapes_needed) + average_size

        # Prepare.
        tape_contents = []
        tape_bytes_left = []
        for i in 0..(tapes_needed - 1)
            tape_contents[i] = []
            tape_bytes_left[i] = bytes_per_tape
        end

        # Bin packing of files. Using First Fit Decreasing algorithm.
        file_count = files.length()
        for i in 0..(file_count - 1)
            file_size = files[i][2]
            stored = false
            for j in 0..(tapes_needed - 1)
                if (tape_bytes_left[j] > file_size)
                    tape_contents[j] << files[i]
                    tape_bytes_left[j] -= file_size
                    stored = true
                    break
                end
            end
            unless (stored)
                puts(tape_bytes_left.to_s())
                puts("Error: Failed to store file #{files[i][4]} (#{files[i][2]} bytes). All tapes are full.")
                error = true
            end
        end
    end

    # Bin packing done? -> Report if verbose.
    unless (error)
        if ($state.verbose)
            for i in 0..(tapes_needed - 1)
                bytes_on_tape = bytes_per_tape - tape_bytes_left[i]
                tape_use_percentage =  (bytes_on_tape.to_f / first_tape_size) * 100
                puts("Tape #{i} holds #{bytes_on_tape} bytes in #{tape_contents[i].length()} files and is used [#{tape_use_percentage.round(2)}]%.")
                limit = [tape_contents[i].length() - 1, 9].min()
                for j in 0..limit
                    puts("  #{j}: #{tape_contents[i][j][4]}")
                end
            end
        end
    end

    # Bin packing done? -> Check if sufficient free tapes are available.
    unless (error)
        tapes_required = tapes_needed * set_count

        free_tapes = db.execute('SELECT * FROM tapes WHERE tapeset=-1 ORDER BY label ASC')
        tapes_required = tapes_needed * set_count        
        if (free_tapes.length() < tapes_required)
            puts("Error: Unsufficient free tapes. Available: #{free_tapes.length()} Required: #{tapes_required}")
            error = true
        end
    end

    # Sufficient tapes available? -> Create tapesets in database.
    unless (error)
        tape_index = 0
        for set in 0..(set_count - 1)
            db.execute("INSERT INTO tapesets (name, tape_count) VALUES (\"#{tapeset_names[set]}\", #{tapes_needed})")
            tapeset_added(tapeset_names[set])
            set_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset_names[set]}\"").to_i

            for tape in 0..(tapes_needed - 1)
                tape_index_in_set = tape_index % tapes_needed
                db.execute("UPDATE tapes SET tapeset=#{set_number}, tapeset_idx=#{tape_index_in_set} WHERE label=\"#{free_tapes[tape_index][1]}\"")
                tape_updated(free_tapes[tape_index][1])

                tape_contents[tape_index_in_set].each() do |file|
                    db.execute("INSERT INTO file_tape_links (file_number, tape_number) VALUES (#{file[0]}, #{free_tapes[tape_index][0]})")
                    file_tape_link_added(file[4], free_tapes[tape_index][1])
                end

                tape_index += 1
            end
        end
    end
end

def tool_update_tapesets()
    db = $state.db

    in_db = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{$state.items[0]}\"")
    if (in_db > 0)
        db.execute("UPDATE tapesets SET name=\"#{$state.name}\" WHERE name=\"#{$state.items[0]}\"")
        tapeset_updated($state.items[0])
    else
        tapeset_doesnt_exist($state.items[0], true)
    end
end

def tool_remove_tapesets()
    db = $state.db
    $state.items.each() do |tapeset|
        # Fetch the needed data for the operation from the database.
        data = db.execute("SELECT tapesets.number, tapesets.name, tapes.number, tapes.label, files.number, files.path, files.on_disk FROM tapesets LEFT JOIN tapes ON tapes.tapeset=tapesets.number LEFT JOIN file_tape_links ON file_tape_links.tape_number=tapes.number LEFT JOIN files ON files.number=file_tape_links.file_number WHERE tapesets.name=\"#{tapeset}\"")

        if (data.length() > 0)
            tape_number = -1
            data.each() do |row|
                # Update the tape if it has not been updated before.
                if (row[2] != tape_number)
                    tape_number = row[2]
                    db.execute("UPDATE tapes SET tapeset=-1, tapeset_idx=-1 WHERE number=#{tape_number}")
                    tape_updated(row[3])
                end

                # Remove the file <-> tape link.
                db.execute("DELETE FROM file_tape_links WHERE tape_number=#{row[2]} AND file_number=#{row[4]}")
                file_tape_link_removed(row[3], row[5])

                # If no longer on disk, we must check if the file is member of other tapesets. If not, delete it.
                if (row[6] == 0)
                    in_other_tapesets = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{row[4]}").to_i()
                    if (in_other_tapesets == 0)
                        db.execute("DELETE FROM files WHERE number=#{row[4]}")
                        file_removed(row[5])
                    end
                end
            end

            db.execute("DELETE FROM tapesets WHERE name=\"#{tapeset}\"")
            tapeset_removed(tapeset)
        else
            tapeset_doesnt_exist(tapeset, true)
        end
    end
end

def tool_list_tapesets()
    query = 'SELECT name FROM tapesets'
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |item|
            query += " name LIKE \"%#{item}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY name ASC'
    db = $state.db
    tapesets = db.execute(query)
    tapesets.collect!() do |tapeset|
        {:label => tapeset[0]}
    end
    tp(tapesets, :label)
end

def tool_info_tapesets()
    query = ''
    if ($state.items.length() == 0)
        query = 'SELECT tapesets.name, tapes.label, tapesets.number, tapes.tapeset_idx, tapesets.tape_count FROM tapes LEFT JOIN tapesets ON tapesets.number=tapes.tapeset WHERE tapes.tapeset!=-1 ORDER BY tapes.label ASC'
    else
        query = 'SELECT tapesets.name, tapes.label, tapesets.number, tapes.tapeset_idx, tapesets.tape_count FROM tapes LEFT JOIN tapesets ON tapesets.number=tapes.tapeset WHERE'
        $state.items.each() do |item|
            query += " tapesets.name=\"#{item}\" OR"
        end
        query.chomp!(' OR')
        query += ' ORDER BY tapes.label ASC'
    end
    db = $state.db
    info = db.execute(query)

    info.collect!() do |row|
        {:name => row[0], :tape => row[1], :volume => "#{(row[3] + 1)} / #{row[4]}"}
    end
    tp(info, :name, :tape, :volume)
end

begin
    # Parse command line and check if all is correct.
    error = !tool_check_command_line(tool_parse_command_line())

    # Startup banner, if not in quiet mode.
    unless ($state.quiet)
        puts("Filetool (Version #{$state.version}, DB Version #{$state.db_version})")
    end

    unless (error)
        db_init()

        # Handle file mode.
        if ($state.mode == 'file')
            case $state.action
            when 'add'
                tool_add_files()
            when 'update'
                tool_update_files()
            when 'remove'
                tool_remove_files()
            end
        end

        # Handle path mode.
        if ($state.mode == 'path')
            case $state.action
            when 'add'
                tool_add_paths()
            when 'update'
                tool_update_paths()
            when 'remove'
                tool_remove_paths()
            when 'prune'
                tool_prune_paths()
            end
        end

        # Handle tape mode.
        if ($state.mode == 'tape')
            case $state.action
            when 'add'
                tool_add_tapes()
            when 'remove'
                tool_remove_tapes()
            when 'list'
                tool_list_tapes()
            when 'info'
                tool_info_tapes()
            when 'manifest'
                tool_manifest_tapes()
            when 'write'
                tool_write_tapes()
            end
        end

        # Handle tapeset mode.
        if ($state.mode == 'tapeset')
            case $state.action
            when 'add'
                tool_add_tapesets()
            when 'update'
                tool_update_tapesets()
            when 'remove'
                tool_remove_tapesets()
            when 'list'
                tool_list_tapesets()
            when 'info'
                tool_info_tapesets()
            end
        end

        # Generate report at end of execution.
        unless ($state.quiet)
            $state.report.report()
        end
    end
rescue SQLite3::Exception => e 
    puts("Database exception occurred:")
    puts(e)
ensure
    db = $state.db
    db.close() if (db)
end

