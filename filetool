#!/usr/bin/ruby

require 'optparse'
require 'sqlite3'

#-------------------------------------------------------------------------------
# Class definitions

class Report
    attr_accessor :file_added, :file_updated, :file_removed
    attr_accessor :tape_added, :tape_updated, :tape_removed
    attr_accessor :tapeset_added, :tapeset_updated, :tapeset_removed
    attr_accessor :link_added, :link_updated, :link_removed

    def initialize()
        @file_added = 0
        @file_updated = 0
        @file_removed = 0

        @tape_added = 0
        @tape_updated = 0
        @tape_removed = 0

        @tapeset_added = 0
        @tapeset_updated = 0
        @tapeset_removed = 0

        @link_added = 0
        @link_updated = 0
        @link_removed = 0
    end

    def report()
        sum = 0
        sum += @file_added + @file_updated + @file_removed
        sum += @tape_added + @tape_updated + @tape_removed
        sum += @tapeset_added + @tapeset_updated + @tapeset_removed
        sum += @link_added + @link_updated + @link_removed
        puts("Report:")
        puts("  #{@file_added} file records added.") if @file_added > 0
        puts("  #{@file_updated} file records updated.") if @file_updated > 0
        puts("  #{@file_removed} file records removed.") if @file_removed > 0
        puts("  #{@tape_added} tape records added.") if @tape_added > 0
        puts("  #{@tape_updated} tape records updated.") if @tape_updated > 0
        puts("  #{@tape_removed} tape records removed.") if @tape_removed > 0
        puts("  #{@tapeset_added} tapeset records added.") if @tapeset_added > 0
        puts("  #{@tapeset_updated} tapeset records updated.") if @tapeset_updated > 0
        puts("  #{@tapeset_removed} tapeset records removed.") if @tapeset_removed > 0
        puts("  #{@link_added} file <-> tape link records added.") if @link_added > 0
        puts("  #{@link_updated} file <-> tape link records updated.") if @link_updated > 0
        puts("  #{@link_removed} file <-> tape link records removed.") if @link_removed > 0
        puts('  No database modifications.') if sum == 0
    end
end

class State
    attr_accessor :db, :version, :db_version, :report, :mode, :action
    attr_accessor :verbose, :quiet, :relative, :duplicates, :items, :incompatible

    def initialize()
        @db = nil
        @version = 1
        @db_version = 1
        @report = Report.new()
        @mode = ''
        @action = ''
        
        @verbose = false
        @quiet = false
        @relative = false
        @duplicates = false

        @items = []

        @incompatible = false
    end
end

#-------------------------------------------------------------------------------
# Global vars section

$state = State.new()

#-------------------------------------------------------------------------------
# DB method section

def db_empty?()
    db = $state.db

    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')

    version_table.length == 0
end

def db_create_version_table()
    db = $state.db

    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')

    db.execute("INSERT INTO version(version, db_version) VALUES(#{$state.version}, #{$state.db_version})")
end

def db_create_files_table()
    db = $state.db
    
	db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, 
        sha1 TEXT, size INTEGER, mtime INTEGER, path TEXT, latest INTEGER,
        deleted INTEGER)')

	db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
	db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY,
        label TEXT, size INTEGER, tapeset INTEGER, tapeset_idx INTEGER)')
end

def db_create_tapesets_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY,
        name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_file_tape_links_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS file_tape_links(file_number INTEGER, 
        tape_number INTEGER)')
end

def db_create_schema()
    unless ($state.quiet)
        puts('Initializing new database.')
    end
    db_create_version_table()
    db_create_files_table()
    db_create_tapes_table()
    db_create_tapesets_table()
    db_create_file_tape_links_table()
end

def db_increment_schema(current)
    db = $state.db

    unless ($state.quiet)
        puts("Updating database schema from V#{current}.")
    end

    if (current == 1)
        # TODO: Handle schema update from V1 to V2 here.
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1

    db.execute("UPDATE version SET db_version=#{current}")

    return current
end

def db_update_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != $state.version)
        db.execute("UPDATE version SET version=#{$state.version}")
    end

    while (db_version_in_db < $state.db_version)
        db_version_in_db = db_increment_schema(db_version_in_db)
    end
end

def db_check_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db > $state.version) || (db_version_in_db > $state.db_version)
        puts('Error: Database was created with higher code or database version of the tools.')
        $state.incompatible = true
        return
    end
    
    db_update_schema()
end

def db_init()
    db = SQLite3::Database.new("filetools.db")
    $state.db = db

    if (db_empty?)
        db_create_schema()
    else
        db_check_schema()
    end

    if ($state.incompatible)
        exit(-1)
    end

    unless ($state.quiet)
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM files').to_s + ' file records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapes').to_s + ' tape records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapesets').to_s + ' tape set records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM file_tape_links').to_s + ' file <-> tape link records in database.')
    end
end

#-------------------------------------------------------------------------------
# File method section

#-------------------------------------------------------------------------------
# Path method section

#-------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if label.length != 8
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

#-------------------------------------------------------------------------------
# Tool method section

def tool_check_command_line(command_line)
    # If in tape mode, parse items array for possible input from barcode reader.
    if ($state.mode == 'tape')
        new_items = []
        $state.items.each() do |str|
            new_items << str.split('*').reject { |c| c.empty? }
        end
        new_items.flatten!.uniq!
        $state.items = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune write erase verify], \
        'path' => %w[manifest write erase verify], \
        'tape' => %w[update prune check], \
        'tapeset' => %w[update manifest prune check write erase verify] \
    }
    if (illegal[$state.mode] == nil)
        puts("Error: Unsupported mode #{$state.mode} specified.")
        return false
    elsif (illegal[$state.mode].include?($state.action))
        puts("Error: Mode #{$state.mode} cannot be combined with action #{$state.action}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check write erase verify]
    unless (legal.include?($state.action))
        puts("Error: Unsupported action #{$state.action} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = 0
    max = 0
    case $state.action
    when 'add', 'update', 'remove', 'info', 'prune', 'check'
        min = 1
        max = -1
    when 'list'
        min = 0
        max = -1
    when 'manifest', 'write', 'erase', 'verify'
        min = 1
        max = 1
    end
    if ($state.items.length() < min)
        puts("Error: At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && ($state.items.length() > max)
        puts("Error: Maximum #{max} items may be specified.")
        return false
    end

    # Check if all items are valid files if in file mode.
    if ($state.mode == 'file')
        $state.items.each() do |file|
            unless (File.file?(file))
                puts("Error: Incorrect file name: #{file}")
                return false
            end
        end
    end

    # Check if all items are valid paths if in path mode.
    if ($state.mode == 'path')
        $state.items.each() do |path|
            unless (File.directory?(path))
                puts("Error: Incorrect path name: #{path}")
                return false
            end
        end
    end

    # Check if all items are valid tapes if in tape mode.
    if ($state.mode == 'tape')
        $state.items.each() do |label|
            unless (tape_valid_label?(label))
                puts("Error: Incorrect tape label: #{label}")
                return false
            end
        end
    end

    # All is OK!
    return true
end

def tool_parse_command_line()
    parser = OptionParser.new() do |options|
        options.on('-h', '--help', 'Displays this help message.') do ||
            puts(options)
        end

        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            $state.mode = mode
        end

        options.on('-a', '--add item', 'Adds the specified item.') do |item|
            $state.action = 'add'
            $state.items << item
        end
        options.on('-u', '--update item', 'Updates the specified item.') do |item|
            $state.action = 'update'
            $state.items << item
        end
        options.on('-r', '--remove item', 'Removes the specified item.') do |item|
            $state.action = 'remove'
            $state.items << item
        end
        options.on('-l', '--list [item]', 'Lists the specified item.') do |item|
            $state.action = 'list'
            $state.items << item if item
        end
        options.on('-i', '--info item', 'Displays info about the specified item.') do |item|
            $state.action = 'info'
            $state.items << item
        end
        options.on('-M', '--manifest tape', 'Displays the manifest of the specified tape.') do |tape|
            $state.action = 'manifest'
            $state.items << item
        end
        options.on('-p', '--prune item', 'Prunes the specified item.') do |item|
            $state.action = 'prune'
            $state.items << item
        end
        options.on('-c', '--check item', 'Checks the specified item.') do |item|
            $state.action = 'check'
            $state.items << item
        end
        options.on('-w', '--write tape', 'Writes the specified tape.') do |tape|
            $state.action = 'write'
            $state.items << item
        end
        options.on('-e', '--erase tape', 'Erases the specified tape.') do |tape|
            $state.action = 'erase'
            $state.items << item
        end
        options.on('-V', '--verify tape', 'Verifies the specified tape.') do |tape|
            $state.action = 'verify'
            $state.items << item
        end

        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            $state.verbose = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            $state.quiet = true
            $state.verbose = false
        end
        options.on('-R', '--relative', 'Display paths as relative.') do ||
            $state.relative = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            $state.duplicates = true
        end
    end
    parser.parse!
    $state.items.flatten!
end

begin
    unless ($state.quiet)
        puts("Filetool (Version #{$state.version}, DB Version #{$state.db_version})")
    end

    error = !tool_check_command_line(tool_parse_command_line())
    unless (error)
        db_init()

        # TODO: Operational logic of the tool goes here.        

        unless ($state.quiet)
            $state.report.report()
        end
    end
rescue SQLite3::Exception => e 
    puts "Database exception occurred:"
    puts e
ensure
    db = $state.db
    db.close if db
end

