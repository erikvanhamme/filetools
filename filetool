#!/usr/bin/ruby

require 'digest/sha1'
require 'find'
require 'optparse'
require 'pathname'
require 'sqlite3'
require 'table_print'

#-------------------------------------------------------------------------------
# Class definitions

class Report
    attr_accessor :file_added, :file_updated, :file_removed
    attr_accessor :tape_added, :tape_updated, :tape_removed
    attr_accessor :tapeset_added, :tapeset_updated, :tapeset_removed
    attr_accessor :link_added, :link_updated, :link_removed

    def initialize()
        @file_added = 0
        @file_updated = 0
        @file_removed = 0

        @tape_added = 0
        @tape_updated = 0
        @tape_removed = 0

        @tapeset_added = 0
        @tapeset_updated = 0
        @tapeset_removed = 0

        @link_added = 0
        @link_updated = 0
        @link_removed = 0
    end

    def report()
        sum = 0
        sum += @file_added + @file_updated + @file_removed
        sum += @tape_added + @tape_updated + @tape_removed
        sum += @tapeset_added + @tapeset_updated + @tapeset_removed
        sum += @link_added + @link_updated + @link_removed
        puts("Report:")
        puts("  #{@file_added} file records added.") if @file_added > 0
        puts("  #{@file_updated} file records updated.") if @file_updated > 0
        puts("  #{@file_removed} file records removed.") if @file_removed > 0
        puts("  #{@tape_added} tape records added.") if @tape_added > 0
        puts("  #{@tape_updated} tape records updated.") if @tape_updated > 0
        puts("  #{@tape_removed} tape records removed.") if @tape_removed > 0
        puts("  #{@tapeset_added} tapeset records added.") if @tapeset_added > 0
        puts("  #{@tapeset_updated} tapeset records updated.") if @tapeset_updated > 0
        puts("  #{@tapeset_removed} tapeset records removed.") if @tapeset_removed > 0
        puts("  #{@link_added} file <-> tape link records added.") if @link_added > 0
        puts("  #{@link_updated} file <-> tape link records updated.") if @link_updated > 0
        puts("  #{@link_removed} file <-> tape link records removed.") if @link_removed > 0
        puts('  No database modifications.') if sum == 0
    end
end

class State
    attr_accessor :db, :version, :db_version, :report, :mode, :action
    attr_accessor :verbose, :quiet, :relative, :duplicates, :items, :incompatible, :double, :triple, :name, :ffd

    def initialize()
        @db = nil
        @version = 1
        @db_version = 1
        @report = Report.new()
        @mode = ''
        @action = ''
        
        @verbose = false
        @quiet = false
        @relative = false
        @duplicates = false

        @items = []

        @incompatible = false

        @double = false
        @triple = false
        @ffd = false

        @name = ''
    end
end

#-------------------------------------------------------------------------------
# Global vars section

$state = State.new()

#-------------------------------------------------------------------------------
# DB method section

def db_empty?()
    db = $state.db

    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')

    version_table.length == 0
end

def db_create_version_table()
    db = $state.db

    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')

    db.execute("INSERT INTO version(version, db_version) VALUES(#{$state.version}, #{$state.db_version})")
end

def db_create_files_table()
    db = $state.db
    
	db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, 
        sha1 TEXT, size INTEGER, mtime INTEGER, path TEXT, on_disk INTEGER)')

	db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
	db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY,
        label TEXT, size INTEGER, tapeset INTEGER, tapeset_idx INTEGER)')
end

def db_create_tapesets_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY,
        name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_file_tape_links_table()
    db = $state.db
    
    db.execute('CREATE TABLE IF NOT EXISTS file_tape_links(file_number INTEGER, 
        tape_number INTEGER)')
end

def db_create_schema()
    unless ($state.quiet)
        puts('Initializing new database.')
    end
    db_create_version_table()
    db_create_files_table()
    db_create_tapes_table()
    db_create_tapesets_table()
    db_create_file_tape_links_table()
end

def db_increment_schema(current)
    db = $state.db

    unless ($state.quiet)
        puts("Updating database schema from V#{current}.")
    end

    if (current == 1)
        # TODO: Handle schema update from V1 to V2 here.
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1

    db.execute("UPDATE version SET db_version=#{current}")

    return current
end

def db_update_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != $state.version)
        db.execute("UPDATE version SET version=#{$state.version}")
    end

    while (db_version_in_db < $state.db_version)
        db_version_in_db = db_increment_schema(db_version_in_db)
    end
end

def db_check_schema()
    db = $state.db
    
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db > $state.version) || (db_version_in_db > $state.db_version)
        puts('Error: Database was created with higher code or database version of the tools.')
        $state.incompatible = true
        return
    end
    
    db_update_schema()
end

def db_init()
    db = SQLite3::Database.new("filetool.db")
    $state.db = db

    if (db_empty?)
        db_create_schema()
    else
        db_check_schema()
    end

    if ($state.incompatible)
        exit(-1)
    end

    unless ($state.quiet)
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM files').to_s + ' file records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapes').to_s + ' tape records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM tapesets').to_s + ' tape set records in database.')
        puts('  ' + db.get_first_value('SELECT COUNT(*) FROM file_tape_links').to_s + ' file <-> tape link records in database.')
    end
end

#-------------------------------------------------------------------------------
# File method section

def file_sha1(absolute_path)
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    sha1.hexdigest()
end

def file_exists(file)
    if ($state.verbose)
        puts("File record for #{file} exists.")
    end
end

def file_doesnt_exist(file)
    unless ($state.quiet)
        puts("File record for #{file} does not exist.")
    end
end

def file_added(file)
    $state.report.file_added += 1
    if ($state.verbose)
        puts("File record for #{file} added.")
    end
end

def file_removed(file)
    $state.report.file_removed += 1
    if ($state.verbose)
        puts("File record for #{file} removed.")
    end
end

def file_updated(file)
    $state.report.file_updated += 1
    if ($state.verbose)
        puts("File record for #{file} updated.")
    end
end

def file_add(file)
    db = $state.db
    absolute_path = File.expand_path(file)
    filesize = File.size(absolute_path)
    mtime = File.mtime(absolute_path)

    present_in_db = db.get_first_value("SELECT COUNT(*) FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1").to_i()
    if (present_in_db == 0)
        sha1 = file_sha1(absolute_path)
        db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
        file_added(absolute_path)
    else
        file_exists(absolute_path)
    end
end

def file_update(file)
    db = $state.db
    absolute_path = File.expand_path(file)
    filesize = File.size(absolute_path)
    mtime = File.mtime(absolute_path)

    files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
    if (files.length() == 0)
        file_doesnt_exist(absolute_path)
    elsif (files.length() == 1)
        file = files[0]

        unless ((file[2] == filesize) && (file[3] == mtime.to_i()))
            sha1 = file_sha1(absolute_path)
            file_num = file[0]
            on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

            if (on_tapes != 0)
                db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_num}")
                file_updated(absolute_path)
                db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
                file_added(absolute_path)
            else
                db.execute("UPDATE files SET sha1=\"#{sha1}\", size=#{filesize}, mtime=#{mtime.to_i} WHERE number=#{file_num}")
                file_updated(absolute_path)
            end
        end
    else
        puts("Error: #{absolute_path} appears multiple times as latest file in database.")
    end
end

def file_remove(file)
    db = $state.db
    absolute_path = File.expand_path(file)

    files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
    if (files.length() == 0)
        file_doesnt_exist(absolute_path)
    elsif (files.length() == 1)
        file = files[0]

        file_num = file[0]
        on_tapes = db.get_first_value("SELECT COUNT (*) FROM file_tape_links WHERE file_number=#{file_num}").to_i()

        if (on_tapes != 0)
            db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_num}")
            file_updated(absolute_path)
        else
            db.execute("DELETE FROM files WHERE number=#{file_num}")
            file_removed(absolute_path)
        end
    else
        puts("Error: #{absolute_path} appears multiple times as latest file in database.")
    end
end

# TODO: Figure out if this one is needed. Noone calls it.
def file_view(file)
    db = $state.db
    absolute_path = File.expand_path(file)

    files = db.execute("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
    if (files.length() == 0)
        file_doesnt_exist(absolute_path)
    elsif (files.length() == 1)
        file_num = file[0]
        puts("  #{file[4]} #{file[2]}"); # TODO: Complete display.
    else
        puts("Error: #{absolute_path} appears multiple times as latest file in database.")
    end
end

#-------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if label.length != 8
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L4'
        size = 800000000000
    end
    return size
end

def tape_exists(label, error = false)
    if ($state.verbose)
        e = error ? 'Error: ' : ''
        puts "#{e}Tape record for #{label} exists."
    end
end

def tape_doesnt_exist(label, error = false)
    unless ($state.quiet)
        e = error ? 'Error: ' : ''
        puts("#{e}Tape record for #{label} does not exist.")
    end
end

def tape_added(label)
    $state.report.tape_added += 1
    if ($state.verbose)
        puts("Tape record for #{label} added.")
    end
end

def tape_removed(label)
    $state.report.tape_removed += 1
    if ($state.verbose)
        puts("Tape record for #{label} removed.")
    end
end

def tape_updated(label)
    $state.report.tape_updated += 1
    if ($state.verbose)
        puts "Tape record for #{label} updated."
    end
end

def tapeset_added(name)
    $state.report.tapeset_added += 1
    if ($state.verbose)
        puts "Tapeset record for #{name} added."
    end
end

def tapeset_removed(name)
    $state.report.tapeset_removed += 1
    if ($state.verbose)
        puts "Tapeset record for #{name} removed."
    end
end

def tapeset_exists(name, error = false)
    if ($state.verbose || error)
        e = error ? 'Error: ' : ''
        puts "#{e}Tapeset record for #{name} exists." 
    end
end

def tapeset_doesnt_exist(name, error = false)
    if ($state.verbose || error)
        e = error ? 'Error: ' : ''
        puts("#{e}Tapeset record for #{name} doesnt exist.")
    end
end

def file_tape_link_added(name, label)
    $state.report.link_added += 1
    if ($state.verbose)
        puts "File <-> tape link record for #{name}, #{label} added."
    end
end

def file_tape_link_removed(name, label)
    $state.report.link_removed += 1
    if ($state.verbose)
        puts "File <-> tape link record for #{name}, #{label} removed."
    end
end

#-------------------------------------------------------------------------------
# Tool method section

def tool_check_command_line(command_line)
    # If in tape mode, parse items array for possible input from barcode reader.
    if ($state.mode == 'tape')
        new_items = []
        $state.items.each() do |str|
            new_items << str.split('*').reject() do |c| c.empty?() end
        end
        new_items.flatten!()
        unless (new_items == nil)
            new_items.uniq!()
        end
        $state.items = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune write erase verify], \
        'path' => %w[manifest write erase verify], \
        'tape' => %w[update prune check], \
        'tapeset' => %w[update manifest prune check write erase verify] \
    }
    if (illegal[$state.mode] == nil)
        puts("Error: Unsupported mode #{$state.mode} specified.")
        return false
    elsif (illegal[$state.mode].include?($state.action))
        puts("Error: Mode #{$state.mode} cannot be combined with action #{$state.action}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check write erase verify]
    unless (legal.include?($state.action))
        puts("Error: Unsupported action #{$state.action} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = 0
    max = 0
    case $state.action
    when 'add', 'update', 'remove', 'prune', 'check'
        min = 1
        max = -1
    when 'list', 'info'
        min = 0
        max = -1
    when 'manifest', 'write', 'erase', 'verify'
        min = 1
        max = 1
    end
    if ($state.items.length() < min)
        puts("Error: At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && ($state.items.length() > max)
        puts("Error: Maximum #{max} items may be specified.")
        return false
    end

    # Items do not need to be checked when running list action (fuzzy input allowed.)
    unless($state.action == 'list')
        # Check if all items are valid files if in file mode.
        if ($state.mode == 'file')
            $state.items.each() do |file|
                unless (File.file?(file))
                    puts("Error: Incorrect file name: #{file}")
                    return false
                end
            end
        end

        # Check if all items are valid paths if in path mode. (or when adding in tapeset mode.)
        if (($state.mode == 'path') || (($state.mode == 'tapeset') && ($state.action == 'add')))
            $state.items.each() do |path|
                unless (File.directory?(path))
                    puts("Error: Incorrect path name: #{path}")
                    return false
                end
            end
        end

        # Check if all items are valid tapes if in tape mode, except when in list action.
        if ($state.mode == 'tape')
            $state.items.each() do |label|
                unless (tape_valid_label?(label))
                    puts("Error: Incorrect tape label: #{label}")
                    return false
                end
            end
        end

    end

    # All is OK!
    return true
end

def tool_parse_command_line()
    parser = OptionParser.new() do |options|
        options.separator('')
        options.separator('Mode:')

        # Mode handling.
        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            $state.mode = mode
        end

        options.separator('')
        options.separator('Modifiers:')

        # Modifiers handling.
        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            $state.verbose = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            $state.quiet = true
            $state.verbose = false
        end
        options.on('-R', '--relative', 'Use relative paths in manifest.') do ||
            $state.relative = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            $state.duplicates = true
        end
        options.on('-2', '--double', 'Enables double mode. Generates 2 tapesets.') do ||
            $state.double = true
        end
        options.on('-3', '--triple', 'Enables triple mode. Generates 3 tapesets.') do ||
            $state.triple = true
            $state.double = false
        end
        options.on('-D', '--first-fit-decreasing', 'Use First Fit Decreasing algorithm for packing files onto tapes.') do ||
            $state.ffd = true
        end
        options.on('-n', '--name name', 'Supplies the name of the tapeset.') do |name|
            $state.name = name
        end

        options.separator('')
        options.separator('Actions:')

        # Actions handling.
        options.on('-a', '--add', 'Adds the specified item.') do ||
            $state.action = 'add'
        end
        options.on('-u', '--update', 'Updates the specified item.') do ||
            $state.action = 'update'
        end
        options.on('-r', '--remove', 'Removes the specified item.') do ||
            $state.action = 'remove'
        end
        options.on('-l', '--list', 'Lists the specified item.') do ||
            $state.action = 'list'
        end
        options.on('-i', '--info', 'Displays info about the specified item.') do ||
            $state.action = 'info'
        end
        options.on('-M', '--manifest', 'Displays the manifest of the specified tape.') do ||
            $state.action = 'manifest'
        end
        options.on('-p', '--prune', 'Prunes the specified item.') do ||
            $state.action = 'prune'
        end
        options.on('-c', '--check', 'Checks the specified item.') do ||
            $state.action = 'check'
        end
        options.on('-w', '--write', 'Writes the specified tape.') do ||
            $state.action = 'write'
        end
        options.on('-e', '--erase', 'Erases the specified tape.') do ||
            $state.action = 'erase'
        end
        options.on('-V', '--verify', 'Verifies the specified tape.') do ||
            $state.action = 'verify'
        end

        options.separator('')
        options.separator('Usage:')

        # Show usage if no options specified.
        options.on_tail('-h', '--help', 'Displays this help message.') do || 
            puts(options) 
        end
    end
    parser.parse!

    # What is left over at this point are the items (if any).
    $state.items = ARGV
end

def tool_add_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_add(file)
        end
    end
end

def tool_update_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_update(file)
        end
    end
end

def tool_remove_files()
    $state.items.each() do |file|
        if (File.file?(file))
            file_remove(file)
        end
    end
end

def tool_add_paths()
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
                file_add(path)
            end
        end
    end
end

def tool_update_paths()
    $state.items.each() do |dir|
	    Find.find(dir) do |path|
		    if (File.file?(path))
                file_update(path)
            end
        end
    end
end

def tool_remove_paths()
    $state.items.each() do |dir|
        Find.find(dir) do |path|
	        if File.file?(path)
                file_remove(path)
            end
        end
    end
end

def tool_prune_paths()
end

def tool_add_tapes()
    db = $state.db
    $state.items.each() do |label|
        present_in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"").to_i()
        if (present_in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset, tapeset_idx) VALUES (\"#{label}\", #{size}, -1, -1)")
            tape_added(label)
        else
            tape_exists(label)
        end
    end
end

def tool_remove_tapes()
    db = $state.db
    $state.items.each() do |label|
        tapes = db.execute("SELECT tapeset FROM tapes WHERE label=\"#{label}\"")
        if (tapes.length() > 0)
            if (tapes[0][0] != -1)
                tapeset = db.get_first_value("SELECT name FROM tapesets WHERE number=#{tapes[0][0]}")
                puts("Error: Cannot remove tape #{label} because it is part of tapeset: #{tapeset}.")
            else
                db.execute("DELETE FROM tapes WHERE label=\"#{label}\"")
                tape_removed(label)
            end
        else
            tape_doesnt_exist(label)
        end
    end
end

def tool_list_tapes()
    db = $state.db
    query = 'SELECT label FROM tapes'
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |label|
            query += " label LIKE \"%#{label}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'
    tapes = db.execute(query)
    tapes.collect!() do |tape|
        {:label => tape[0]}
    end
    tp(tapes, :label)
end

def tool_info_tapes()
    db = $state.db
    query = 'SELECT tapes.number, tapes.label, tapes.size, tapes.tapeset_idx, tapesets.name FROM tapes LEFT JOIN tapesets ON tapesets.number = tapes.tapeset' 
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |label|
            query += " tapes.label = \"#{label}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'

    tapes = db.execute(query)
    tapes.collect!() do |tape|
        query = "SELECT * FROM file_tape_links LEFT JOIN files ON file_tape_links.file_number = files.number WHERE file_tape_links.tape_number=#{tape[0]}"
        files = db.execute(query)

        size = 0
        files.each() do |file|
            size += file[4]
        end

        used = (size.to_f() / (tape[2].to_f() * 0.95)) * 100

        {:label => tape[1], :files => files.length(), :size => size, :capacity => tape[2], :usage => "#{used.round(1)} %", :tapeset_idx => tape[3], :tapeset => tape[4]}
    end
    tp(tapes, :label, :files, :size, :capacity, :usage, :tapeset_idx, :tapeset)
end

def tool_manifest_tapes()
    tape_label = $state.items[0]
    unless ($state.quiet)
        puts("File manifest for tape #{tape_label}:")
    end

    db = $state.db
    files = db.execute("SELECT path, sha1 FROM files LEFT JOIN file_tape_links ON file_tape_links.file_number = files.number LEFT JOIN tapes ON tapes.number = file_tape_links.tape_number WHERE tapes.label=\"#{tape_label}\" ORDER BY files.path ASC")

    files.each() do |file|
        filename = file[0]
        filename = Pathname.new(file[0]).relative_path_from(Pathname.new(File.expand_path(File.dirname(__FILE__)))).to_s() if ($state.relative)
        puts("#{file[1]}  #{filename}")
    end
end    

def tool_add_tapesets()
    db = $state.db

    error = false
    files = nil
    no_filter = true
    set_count = 1
    tapeset_names = []
    
    # Handle command line settings from state.
    unless (error)
        if ($state.name.length() == 0)
            tapeset_names << 'tapeset'
        else
            tapeset_names << $state.name
        end
        set_count = 2 if ($state.double)
        set_count = 3 if ($state.triple)
        if (set_count > 1)
            n = tapeset_names[0]
            tapeset_names = []
            for i in 0..(set_count - 1)
                suffix = ''
                case i
                when 0
                    suffix = ' (primary)'
                when 1
                    suffix = ' (secondary)'
                when 2
                    suffix = ' (tertiary)'
                end
                tapeset_names << (n + suffix)
            end
        end
        tapeset_names.each() do |n|
            # Check if the name already exists in the tapesets table.
            c = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{n}\"").to_i()
            if (c > 0)
                tapeset_exists(n, true)
                error = true
            end
        end
    end

    # Command line settings alright? -> Proceed file selection from database.
    unless (error)
        accumulator = 0

        # Build the selection query.
        query = 'SELECT * FROM files'
        first = true
        unless (no_filter)
            query += ' WHERE'
            argv.each() do |arg|
                if (first)
                    query += " (path LIKE \"#{arg}%\""
                    first = false
                else
                    query += " OR path LIKE \"#{arg}%\""
                end
            end
            query += ') AND latest=1 AND deleted=0'
        end
        if ($state.ffd)
            query += ' ORDER BY size DESC'
        else
            query += ' ORDER BY path ASC'
        end

        files = db.execute(query)
        if (files.length() == 0)
            puts("Error: No files matched the selection criteria.")
            error = true
        end
    end

    # File selection alright? -> Proceed to bin packing of the tapes.
    unless (error)
        files.each() do |file|
            accumulator += file[2]
        end
        average_size = accumulator / files.length()

        # TODO: This is bad, find a way to deal with tapes of different sizes.
        first_tape_size = db.get_first_value('SELECT size FROM tapes')

        # Reduce tape size with 5% to make room for TAR blocking overhead.
        first_tape_size = (0.95 * first_tape_size).to_i()

        # Get smallest integer number of tapes that will fit the data.
        tapes_needed = (accumulator.to_f() / first_tape_size).ceil()

        # Add the average file size here to give the bin packing algorithm some wriggle room.
        bytes_per_tape = (accumulator / tapes_needed) + average_size

        # Prepare.
        tape_contents = []
        tape_bytes_left = []
        for i in 0..(tapes_needed - 1)
            tape_contents[i] = []
            tape_bytes_left[i] = bytes_per_tape
        end

        # Bin packing of files. Using First Fit Decreasing algorithm.
        file_count = files.length()
        for i in 0..(file_count - 1)
            file_size = files[i][2]
            tape = 0
            stored = false
            for j in 0..(tapes_needed - 1)
                if (tape_bytes_left[j] > file_size)
                    tape_contents[j] << files[i]
                    tape_bytes_left[j] -= file_size
                    stored = true
                    break
                end
            end
            unless (stored)
                puts("Error: Failed to store file idx(#{i}). All tapes are full.")
                error = true
            end
        end
    end

    # Bin packing done? -> Report if verbose.
    unless (error)
        if ($state.verbose)
            for i in 0..(tapes_needed - 1)
                bytes_on_tape = bytes_per_tape - tape_bytes_left[i]
                tape_use_percentage =  (bytes_on_tape.to_f / first_tape_size) * 100
                puts("Tape #{i} holds #{bytes_on_tape} bytes in #{tape_contents[i].length()} files and is used [#{tape_use_percentage.round(2)}]%.")
                limit = [tape_contents[i].length() - 1, 9].min()
                for j in 0..limit
                    puts("  #{j}: #{tape_contents[i][j][4]}")
                end
            end
        end
    end

    # Bin packing done? -> Check if sufficient free tapes are available.
    unless (error)
        tapes_required = tapes_needed * set_count

        free_tapes = db.execute('SELECT * FROM tapes WHERE tapeset=-1 ORDER BY label ASC')
        tapes_required = tapes_needed * set_count        
        if (free_tapes.length() < tapes_required)
            puts("Error: Unsufficient free tapes. Available: #{free_tapes.length()} Required: #{tapes_required}")
            error = true
        end
    end

    # Sufficient tapes available? -> Create tapesets in database.
    unless (error)
        tape_index = 0
        for set in 0..(set_count - 1)
            db.execute("INSERT INTO tapesets (name, tape_count) VALUES (\"#{tapeset_names[set]}\", #{tapes_needed})")
            tapeset_added(tapeset_names[set])
            set_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset_names[set]}\"").to_i

            for tape in 0..(tapes_needed - 1)
                tape_index_in_set = tape_index % tapes_needed
                db.execute("UPDATE tapes SET tapeset=#{set_number}, tapeset_idx=#{tape_index_in_set} WHERE label=\"#{free_tapes[tape_index][1]}\"")
                tape_updated(free_tapes[tape_index][1])

                tape_contents[tape_index_in_set].each() do |file|
                    db.execute("INSERT INTO file_tape_links (file_number, tape_number) VALUES (#{file[0]}, #{free_tapes[tape_index][0]})")
                    file_tape_link_added(file[4], free_tapes[tape_index][1])
                end

                tape_index += 1
            end
        end
    end
end

def tool_remove_tapesets()
    db = $state.db
    $state.items.each() do |tapeset|
        tapeset_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset}\"")
        if (tapeset_number != nil)
            puts(tapeset_number)

        else
            tapeset_doesnt_exist(tapeset)
        end
    end
end

def tool_list_tapesets()
    query = 'SELECT name FROM tapesets'
    if ($state.items.length() > 0)
        query += ' WHERE'
        $state.items.each() do |item|
            query += " name LIKE \"%#{item}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY name ASC'
    db = $state.db
    tapesets = db.execute(query)
    tapesets.collect!() do |tapeset|
        {:label => tapeset[0]}
    end
    tp(tapesets, :label)
end

def tool_info_tapesets()
    query = ''
    if ($state.items.length() == 0)
        query = 'SELECT tapesets.name, tapes.label, tapesets.number, tapes.tapeset_idx, tapesets.tape_count FROM tapes LEFT JOIN tapesets ON tapesets.number=tapes.tapeset WHERE tapes.tapeset!=-1 ORDER BY tapes.label ASC'
    else
        query = 'SELECT tapesets.name, tapes.label, tapesets.number, tapes.tapeset_idx, tapesets.tape_count FROM tapes LEFT JOIN tapesets ON tapesets.number=tapes.tapeset WHERE'
        $state.items.each() do |item|
            query += " tapesets.name=\"#{item}\" OR"
        end
        query.chomp!(' OR')
        query += ' ORDER BY tapes.label ASC'
    end
    db = $state.db
    info = db.execute(query)

    info.collect!() do |row|
        {:name => row[0], :tape => row[1], :volume => "#{(row[3] + 1)} / #{row[4]}"}
    end
    tp(info, :name, :tape, :volume)
end

begin
    # Parse command line and check if all is correct.
    error = !tool_check_command_line(tool_parse_command_line())

    # Startup banner, if not in quiet mode.
    unless ($state.quiet)
        puts("Filetool (Version #{$state.version}, DB Version #{$state.db_version})")
    end

    unless (error)
        db_init()

        # Handle file mode.
        if ($state.mode == 'file')
            case $state.action
            when 'add'
                tool_add_files()
            when 'update'
                tool_update_files()
            when 'remove'
                tool_remove_files()
            end
        end

        # Handle path mode.
        if ($state.mode == 'path')
            case $state.action
            when 'add'
                tool_add_paths()
            when 'update'
                tool_update_paths()
            when 'remove'
                tool_remove_paths()
            when 'prune'
                tool_prune_paths()
            end
        end

        # Handle tape mode.
        if ($state.mode == 'tape')
            case $state.action
            when 'add'
                tool_add_tapes()
            when 'remove'
                tool_remove_tapes()
            when 'list'
                tool_list_tapes()
            when 'info'
                tool_info_tapes()
            when 'manifest'
                tool_manifest_tapes()
            end
        end

        # Handle tapeset mode.
        if ($state.mode == 'tapeset')
            case $state.action
            when 'add'
                tool_add_tapesets()
            when 'remove'
                tool_remove_tapesets()
            when 'list'
                tool_list_tapesets()
            when 'info'
                tool_info_tapesets()
            end
        end

        # Generate report at end of execution.
        unless ($state.quiet)
            $state.report.report()
        end
    end
rescue SQLite3::Exception => e 
    puts("Database exception occurred:")
    puts(e)
ensure
    db = $state.db
    db.close() if (db)
end

