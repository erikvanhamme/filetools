#!/usr/bin/ruby

# Copyright 2018 Erik Van Hamme
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'digest/sha1'
require 'ffi-xattr'
require 'fileutils'
require 'find'
require 'optparse'
require 'pathname'
require 'sqlite3'
require 'table_print'

#-----------------------------------------------------------------------------------------------------------------------
# Class definitions

class Report
    def initialize(mods)
        @verbose = mods[:verbose]
        @quiet = mods[:quiet]
        @r = { :f_add => 0, :f_up => 0, :f_rm => 0, :t_add => 0, :t_up => 0, :t_rm => 0, :s_add => 0, :s_up => 0, 
            :s_rm => 0, :l_add => 0, :l_rm => 0 }
    end

    def tool_init(version, db_version)
        puts("Filetool (version: #{version}, db_version: #{db_version})") unless (@quiet)
    end

    def db_create()
        puts('New database created.') unless (@quiet)
    end

    def db_increment(from)
        puts("Database schema update from #{from} to #{from + 1}.") unless (@quiet)
    end

    def db_incompatible(version_expected, version, db_version_expected, db_version)
        error("Incompatible versions. (db_v: #{version} > exp_db_v: #{version_expected}) || " +
                "(schema_db_v: #{db_version} > exp_schema_db_v: #{db_version_expected})")
    end

    def db_async()
        puts('Database in asynchronous mode.') unless (@quiet)
    end

    def db_init(files, tapes, tapesets, links)
        data = [{files: files, tapes: tapes, tapesets: tapesets, links: links}]
        puts('Database initialized. Contents:') if (@verbose)
        tp(data, data[0].keys) if (@verbose)
    end

    def db_exception(exception)
        error('SQL exception: ' + exception.to_s())
    end

    def file_added(absolute_path)
        @r[:f_add] += 1
        puts("File #{absolute_path} was added.") if (@verbose)
    end

    def file_updated(absolute_path)
        @r[:f_up] += 1
        puts("File #{absolute_path} was updated.") if (@verbose)
    end

    def file_removed(absolute_path)
        @r[:f_rm] += 1
        puts("File #{absolute_path} was removed.") if (@verbose)
    end

    def file_duplicate(db_absolute_path, match_absolute_path)
        puts("Duplicate file: master=#{db_absolute_path} duplicate=#{match_absolute_path}")
    end

    def tape_added(label)
        @r[:t_add] += 1
        puts("Tape #{label} added.") if (@verbose)
    end

    def tape_updated(label)
        @r[:t_up] += 1
        puts("Tape #{label} updated.") if (@verbose)
    end
    
    def tape_removed(label)
        @r[:t_rm] += 1
        puts("Tape #{label} removed.") if (@verbose)
    end

    def tapeset_added(name)
        @r[:s_add] += 1
        puts("Tapeset #{name} added.") if (@verbose)
    end

    def tapeset_updated(name)
        @r[:s_up] += 1
        puts("Tapeset #{name} updated.") if (@verbose)
    end

    def tapeset_removed(name)
        @r[:s_rm] += 1
        puts("Tapeset #{name} removed.") if (@verbose)
    end

    def link_added(path, label, tapeset)
        @r[:l_add] += 1
        puts("Link added: #{path} #{label} #{tapeset}") if (@verbose)
    end

    def link_removed(path, label, tapeset)
        @r[:l_rm] += 1
        puts("Link removed: #{path} #{label} #{tapeset}") if (@verbose)
    end

    def finalize()
        if (@verbose)
            if ((@r.values.inject(0) do |sum, x| sum + x end) > 0)
                tp([@r], @r.keys)
            else
                puts('No Database modifications.')
            end
        end
    end

    def msg(s)
        puts(s) unless (@quiet)
    end

    def info(s)
        puts(s) unless (@quiet)
    end

    def warning(s)
        puts('Warning: ' + s)
    end

    def error(s)
        puts('Error: ' + s)
    end

    def time(s, t_time)
        puts("#{s} at #{t_time}.") unless (@quiet)
    end
    
    def duration(s, t_start, t_end)
        d = t_end - t_start
        fraction = d % 1
        d -= fraction
        fraction = (fraction * 100).round(0)
        seconds = d % 60
        d = (d - seconds) / 60
        minutes = d % 60
        d = (d - minutes) / 60
        hours = d % 60

        d_s = sprintf('%02d:%02d:%02d.%02d', hours, minutes, seconds, fraction)

        puts("#{s} at #{t_end}. Duration was #{d_s} .") unless (@quiet)
    end
end

class DbWrapper
    def initialize()
        @db = nil
    end

    def wrap(db)
        @db = db
    end

    def execute(sql)
        puts('-> ' + sql)
        return @db.execute(sql)
    end

    def get_first_value(sql)
        puts('-> ' + sql)
        return @db.get_first_value(sql)
    end

    def get_first_row(sql)
        puts('-> ' + sql)
        return @db.get_first_row(sql)
    end

    def changes()
        return @db.changes()
    end

    def close()
        @db.close()
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# DB method section

def db_empty?(db)
    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')
    version_table.empty?()
end

def db_create_version_table(db, version, db_version)
    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')
    db.execute("INSERT INTO version(version, db_version) VALUES(#{version}, #{db_version})")
end

def db_create_files_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, sha1 TEXT, size INTEGER, mtime INTEGER,' +
        ' path TEXT, on_disk INTEGER)')
    db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
    db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY, label TEXT, size INTEGER, tapeset_idx' +
        ' INTEGER, written INTEGER, verified INTEGER)')
end

def db_create_tapesets_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY, name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_links_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS links(file_number INTEGER, tape_number INTEGER, tapeset_number INTEGER)')
end

def db_create_schema(db, report, version, db_version)
    db_create_version_table(db, version, db_version)
    db_create_files_table(db)
    db_create_tapes_table(db)
    db_create_tapesets_table(db)
    db_create_links_table(db)
    report.db_create()
end

def db_increment_schema(db, current, report)
    report.db_increment(current)
    if (current == 1)
        # Create the new links table and fill it with the information from the other tables.
        db_create_links_table(db)
        db.execute('INSERT INTO links (file_number, tape_number, tapeset_number) SELECT file_number, tape_number,' +
            ' tapeset FROM file_tape_links LEFT JOIN tapes ON tapes.number=file_tape_links.tape_number')

        # Drop the column tapeset from tapes table through copying to new table after rename. (Sqlite3 does not support
        # drop column.)
        db.execute('ALTER TABLE tapes RENAME TO tapes_v1')
        db_create_tapes_table(db)
        db.execute('INSERT INTO tapes (number, label, size, tapeset_idx) SELECT number, label, size, tapeset_idx FROM' +
            ' tapes_v1')

        # Drop the unused tables.
        db.execute('DROP TABLE file_tape_links')
        db.execute('DROP TABLE tapes_v1')        
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1
    db.execute("UPDATE version SET db_version=#{current}")
    return current
end

def db_update_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != version)
        db.execute("UPDATE version SET version=#{version}")
    end

    while (db_version_in_db < db_version)
        db_version_in_db = db_increment_schema(db, db_version_in_db, report)
    end
end

def db_check_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if ((version_in_db > version) || (db_version_in_db > db_version))
        report.db_incompatible(version, version_in_db, db_version, db_version_in_db)
        exit(-1) # Impossible to continue.
    end
    
    db_update_schema(db, report, version, db_version)
end

def db_init(report, version, db_version, async, wrapper = nil)
    if (wrapper.nil?)
        db = SQLite3::Database.new("filetool.db")
    else
        wrapper.wrap(SQLite3::Database.new("filetool.db"))
        db = wrapper
    end

    if (async)
        db.execute('PRAGMA synchronous = OFF')
        report.db_async()
    end

    if (db_empty?(db))
        db_create_schema(db, report, version, db_version)
    else
        db_check_schema(db, report, version, db_version)
    end

    files = db.get_first_value('SELECT COUNT(*) FROM files')
    tapes = db.get_first_value('SELECT COUNT(*) FROM tapes')
    tapesets = db.get_first_value('SELECT COUNT(*) FROM tapesets')
    links = db.get_first_value('SELECT COUNT(*) FROM links')
    report.db_init(files, tapes, tapesets, links)

    return db
end

#-----------------------------------------------------------------------------------------------------------------------
# File method section

def file_sha1(absolute_path)
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    return sha1.hexdigest()
end

def file_add(db, report, files)
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            in_db = db.get_first_value("SELECT COUNT(*) FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            if (in_db == 0)
                filesize = File.size(absolute_path)
                mtime = File.mtime(absolute_path)
                sha1 = file_sha1(absolute_path)
                db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}," +
                    "#{mtime.to_i}, \"#{absolute_path}\", 1)")
                report.file_added(absolute_path)
            end
        end
    end
end

def file_update(db, report, files)
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            filesize = File.size(absolute_path)
            mtime = File.mtime(absolute_path)
            file_in_db = db.get_first_row("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            if ((file_in_db.nil?() == false) && ((file_in_db[2] != filesize) || (file_in_db[3] != mtime.to_i())))
                sha1 = file_sha1(absolute_path)
                file_on_tapes = db.get_first_value("SELECT COUNT(*) FROM links WHERE file_number=#{file_in_db[0]}")
                if (file_on_tapes > 0)
                    # Older version on tape, cannot update existing record.
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                    db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\"," +
                        " #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
                    report.file_added(absolute_path)
                else
                    # No versions on tape, can update existing record.
                    db.execute("UPDATE files SET sha1=\"#{sha1}\", size=#{filesize}, mtime=#{mtime.to_i()} WHERE" +
                        " number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                end
            end
        end
    end
end

def file_remove(db, report, files)
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            file_in_db = db.get_first_row("SELECT number FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            unless (file_in_db.nil?)
                file_on_tapes = db.get_first_value("SELECT COUNT(*) FROM links WHERE file_number=#{file_in_db[0]}")
                if (file_on_tapes > 0)
                    # File is on tape, cannot remove record, update it as no longer on disk.
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                else
                    # File is not on tape, can be removed.
                    db.execute("DELETE FROM files WHERE number=#{file_in_db[0]}")
                    report.file_removed(absolute_path)
                end
            end
        end
    end
end

def file_list(db, files_fuzzy)
    # TODO: Implement me.
end

def file_info(db, files)
    # TODO: Implement me.
end

def file_check(db, report, files)
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            sha1 = file_sha1(absolute_path)
            matching_sha1 = db.execute("SELECT path FROM files WHERE sha1=\"#{sha1}\" AND on_disk=1 AND NOT" +
                " path=\"#{absolute_path}\"")
            matching_sha1.each() do |match|
                report.file_duplicate(absolute_path, match[0])
            end
        end
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Path method section

def path_add(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_add(db, report, files)
end

def path_update(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_update(db, report, files)
end

def path_remove(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_remove(db, report, files)
end

def path_list(db, paths_fuzzy)
    # TODO: Implement me.
end

def path_info(db, paths)
    # TODO: Implement me.
end

def path_prune(db, report, paths)
    paths.each() do |path|
        absolute_path = File.expand_path(path)
        files = db.execute("SELECT number, path FROM files WHERE path LIKE \"#{absolute_path}%\" AND on_disk=1")
        files.each() do |file|
            unless (File.file?(file[1]))
                on_tape = db.get_first_value("SELECT COUNT (*) FROM links WHERE file_number=#{file[0]}")
                if (on_tape > 0)
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file[0]}")
                    report.file_updated(file[1])
                else
                    db.execute("DELETE FROM files WHERE number=#{file[0]}")
                    report.file_removed(file[1])
                end
            end
        end
    end
end

def path_check(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_check(db, report, files)
end

#-----------------------------------------------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if (label.length() != 8)
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8 for now.
    return label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L4'
        size = 800000000000
    end
    return size
end

def tape_add(db, report, tapes)
    tapes.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset_idx) VALUES (\"#{label}\", #{size}, -1)")
            report.tape_added(label)
        else
            report.error("Tape with label #{label} is already in the database.")
        end
    end
end

def tape_update(db, report, old_name, new_name)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{new_name}\"")
    if (in_db == 0)
        db.execute("UPDATE tapes SET label=\"#{new_name}\", written=NULL, verified=NULL WHERE label=\"#{old_name}\"")
        report.tape_updated(old_name)
    else
        report.error("Cannot rename #{old_name} to #{new_name}, #{new_name} exists in the database.")
    end
end

def tape_remove(db, report, tapes)
    tapes.each() do |label|
        count = db.get_first_value("SELECT COUNT (*) FROM links LEFT JOIN tapes ON tapes.number=links.tape_number" +
            " WHERE tapes.label=\"#{label}\"")
        if (count == 0)
            db.execute("DELETE FROM tapes WHERE label=\"#{label}\"")
            report.tape_removed(label)
        else
            report.error("Tape with label #{label} is part of a tapeset.") 
        end
    end
end

def tape_list(db, tapes_fuzzy)
    query = 'SELECT label FROM tapes'
    unless (tapes_fuzzy.empty?())
        query += ' WHERE'
        tapes_fuzzy.each() do |label|
            query += " label LIKE \"#{label}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'
    tapes = db.execute(query)
    tapes.collect!() do |tape|
        {:label => tape[0]}
    end
    tp(tapes, :label)
end

def tape_info(db, tapes)
    query = 'SELECT DISTINCT tapes.number, tapes.label, tapes.size, tapes.tapeset_idx, tapesets.name, tapes.written,' +
        ' tapes.verified FROM tapes LEFT JOIN links ON links.tape_number=tapes.number LEFT JOIN tapesets ON' +
        ' tapesets.number=links.tapeset_number'
    unless (tapes.empty?())
        query += ' WHERE'
        tapes.each() do |label|
            query += " label=\"#{label}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY tapes.label ASC'

    tapes = db.execute(query)
    tapes.collect!() do |tape|
        query = "SELECT files.size FROM links LEFT JOIN files ON links.file_number = files.number WHERE " +
            " links.tape_number=#{tape[0]}"
        files = db.execute(query)

        size = 0
        overhead = 0
        files.each() do |file|
            size += file[0]
            overhead += (512 * 3) + (512 - (file[0] % 512))
        end
        tar_size_no_footer = size + overhead
        modulo = tar_size_no_footer % (8192 * 512)
        if (modulo < 1024)
            tar_footer_size = (8192 * 512) + modulo
        else
            tar_footer_size = (8192 * 512) - modulo
        end
        tar_size = tar_size_no_footer + tar_footer_size
        used = (tar_size.to_f() / (tape[2].to_f() * 0.95)) * 100
        overhead += tar_footer_size

        w = tape[5].nil? ? nil : Time.at(tape[5])
        v = tape[6].nil? ? nil : Time.at(tape[6])

        {:label => tape[1], :files => files.length(), :size => size, :tar_size => tar_size, :overhead => overhead,
            :capacity => tape[2], :usage => "#{used.round(1)} %", :ts_idx => tape[3], :tapeset => tape[4], 
            :written => w, :verified => v}
    end
    tp(tapes, :label, :files, :size, :tar_size, :overhead, :capacity, :usage, :ts_idx, :tapeset, :written, :verified)
end

def tape_manifest(db, report, tapes, mods)
    tapes.each() do |label|
        report.info("Manifest for tape with label #{label}:")
        files = db.execute("SELECT path, sha1 FROM files LEFT JOIN links ON links.file_number=files.number LEFT" +
            " JOIN tapes ON tapes.number=links.tape_number WHERE tapes.label=\"#{label}\" ORDER BY files.path ASC")
        files.each() do |file|
            filename = file[0]
            filename = Pathname.new(file[0]).relative_path_from(Pathname.new(File.expand_path(
                File.dirname(__FILE__)))).to_s() if (mods[:relative])
            report.info("#{file[1]}  #{filename}")
        end
    end
end

def tape_written(db, report, tapes)
    now = Time.new().to_i()
    query = "UPDATE tapes SET written=#{now} WHERE"
    tapes.each() do |label|
        query += " label=\"#{label}\" OR"
    end
    query.chomp!(' OR')
    db.execute(query)
    tapes.each() do |label|
        report.tape_updated(label)
    end
end

def tape_verified(db, report, tapes)
    now = Time.new().to_i()
    query = "UPDATE tapes SET verified=#{now} WHERE"
    tapes.each() do |label|
        query += " label=\"#{label}\" OR"
    end
    query.chomp!(' OR')
    db.execute(query)
    tapes.each() do |label|
        report.tape_updated(label)
    end
end

def tape_erased(db, report, tapes)
    query = "UPDATE tapes SET written=NULL, verified=NULL WHERE"
    tapes.each() do |label|
        query += " label=\"#{label}\" OR"
    end
    query.chomp!(' OR')
    db.execute(query)
    tapes.each() do |label|
        report.tape_updated(label)
    end
end

def tape_write(db, report, tapes, mods)
    tapes.each() do |label|
        begin
            # Get the file data of the involved files.
            all_files = db.execute("SELECT path, sha1, on_disk, mtime FROM files LEFT JOIN links ON links.file_number" +
                "=files.number LEFT JOIN tapes ON tapes.number=links.tape_number WHERE tapes.label=\"#{label}\"" +
                " ORDER BY files.path ASC")
            
            # Filter the list of files to write to tape.
            write_files = []
            all_files.each() do |file|
                on_disk = (file[2] == 1)
                exists = File.file?(file[0])
                mtime_ok = exists ? File.mtime(file[0]).to_i() == file[3] : false

                if (on_disk && exists && mtime_ok)
                    write_files << file
                else
                    report.warning("File does not qualify to be written on tape: #{file[0]}")
                end
            end

            # Open and make the files.
            checksums_file = File.open('checksums.txt', 'w')
            manifest_file = File.open('manifest.txt', 'w')
            manifest_file.puts('manifest.txt')
            manifest_file.puts('checksums.txt')
            write_files.each() do |file|
                relative_path = Pathname.new(file[0]).relative_path_from(Pathname.new(
                    File.expand_path(File.dirname(__FILE__)))).to_s()

                manifest_file.puts(relative_path)
                checksums_file.puts("#{file[1]}  #{relative_path}")
            end
        rescue IOError => e
            puts(e)
        ensure
            checksums_file.close() unless checksums_file.nil?
            manifest_file.close() unless manifest_file.nil?
        end

        # Set xattr user.sha1 for complete tar contents.
        checksums_sha1 = file_sha1('checksums.txt')
        xattr = Xattr.new('checksums.txt')
        xattr['user.sha1'] = checksums_sha1
        manifest_sha1 = file_sha1('manifest.txt')
        xattr = Xattr.new('manifest.txt')
        xattr['user.sha1'] = manifest_sha1
        write_files.each() do |file|
            xattr = Xattr.new(file[0])
            xattr['user.sha1'] = file[1]
        end

        # Set start time.
        t_start = Time.now()
        report.time("Start write of tape #{label} on #{mods[:device]}", t_start)

        # Write tape and rewind it if needed.
        output = `tar -H pax --xattrs -b 8192 -cf #{mods[:device]} -T manifest.txt`
        unless (output == '')
            report.error("Tar error: #{output}")
        end
        unless (mods[:no_rewind])
            output = `mt-st -f #{mods[:device]} rewoffl`
            unless (output == '')
                report.error("Mt-st error: #{output}")
            end
        end

        # Mark tape as written.
        tape_written(db, report, tapes)

        # Set end time and report.
        t_end = Time.now()
        report.duration("Finished writing tape ", t_start, t_end)
    end
end

def tape_verify(db, report, tapes, mods)
    tapes.each() do |label|
        t_start = Time.now()
        report.time("Start verify of tape #{label} on #{mods[:device]}", t_start)

        ok = tar_verify(report, mods[:device], 8192)

        if (ok)
            tape_verified(db, report, tapes)
        end

        t_end = Time.now()
        report.duration("Done verifying with result ok=#{ok}", t_start, t_end)
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Tapeset method section

def tapeset_add(db, report, paths, mods)
    # 1. Assemble the tapeset names.
    tapeset_names = []
    name = 'tapeset' if (mods[:name].length() == 0)
    if (mods[:sets] == 1)
        tapeset_names << mods[:name]
    else
        for set in 0..(mods[:sets] - 1)
            case set
            when 0
                suffix = ' (primary)'
            when 1
                suffix = ' (secondary)'
            when 2
                suffix = ' (tertiary)'
            end
            tapeset_names << (mods[:name] + suffix)
        end
    end
    tapeset_names.each() do |n|
        # Check if the name already exists in the tapesets table.
        c = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{n}\"")
        if (c > 0)
            report.error("Tapeset with name #{n} already exists in database.")
            return
        end
    end

    # 2. File selection.
    files = nil
    if (mods[:incremental])
        # TODO: Implement incremental mode.
    else
        query = 'SELECT * FROM files WHERE ('
        paths.each() do |item|
            query += "path LIKE \"#{item}%\" OR "
        end
        query.chomp!(' OR ')
        query += ') AND (on_disk=1)'
        if (mods[:ffd])
            query += ' ORDER BY size DESC'
        else
            query += ' ORDER BY path ASC'
        end
        files = db.execute(query)
    end
    if (files.length() == 0)
        report.error("No files matched the selection criteria.")
        return
    end

    # 3. Bin packing.
    accumulator = 0
    files.each() do |file|
        accumulator += file[2]
        accumulator += (3 * 512) # Tar header overhead.
    end
    average_size = accumulator / files.length()

    # TODO: This is bad, find a way to deal with tapes of different sizes.
    first_tape_size = db.get_first_value('SELECT size FROM tapes')

    # Reduce tape size with 5% to make room for TAR blocking overhead.
    first_tape_size = (0.95 * first_tape_size).to_i()

    # Get smallest integer number of tapes that will fit the data.
    tapes_needed = (accumulator.to_f() / first_tape_size).ceil()

    # Add the average file size here to give the bin packing algorithm some wriggle room.
    bytes_per_tape = (accumulator / tapes_needed) + average_size

    # Prepare.
    tape_contents = []
    tape_bytes_left = []
    tape_bytes_files = []
    tape_bytes_overhead = []
    for i in 0..(tapes_needed - 1)
        tape_contents[i] = []
        tape_bytes_left[i] = bytes_per_tape
        tape_bytes_files[i] = 0
        tape_bytes_overhead[i] = 0
    end

    # Actual bin packing of files.
    file_count = files.length()
    for i in 0..(file_count - 1)
        overhead = (512 * 3) + (512 - (files[i][2] % 512))
        file_size = (files[i][2])

        stored = false
        for j in 0..(tapes_needed - 1)
            if (tape_bytes_left[j] > (file_size + overhead + 1024)) # Add 1024 bytes for the tarball footer.
                tape_contents[j] << files[i]
                tape_bytes_left[j] -= (file_size + overhead)
                tape_bytes_files[j] += file_size
                tape_bytes_overhead[j] += overhead
                stored = true
                break
            end
        end
        unless (stored)
            report.error("Failed to store file #{files[i][4]} (#{files[i][2]} bytes). All tapes are full.")
            return
        end
    end

    # 4. Check if enough tapes are available.
    tapes_required = tapes_needed * mods[:sets]
    free_tapes = db.execute('SELECT * FROM tapes WHERE tapeset_idx=-1 ORDER BY label ASC')
    tapes_required = tapes_needed * mods[:sets]        
    if (free_tapes.length() < tapes_required)
        report.error("Unsufficient free tapes. Available: #{free_tapes.length()} Required: #{tapes_required}")
        return
    end

    # 5. Create tapesets in database.
    tape_index = 0
    tapes_used = []
    for set in 0..(mods[:sets] - 1)
        db.execute("INSERT INTO tapesets (name, tape_count) VALUES (\"#{tapeset_names[set]}\", #{tapes_needed})")
        report.tapeset_added(tapeset_names[set])
        set_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset_names[set]}\"")

        for tape in 0..(tapes_needed - 1)
            tape_index_in_set = tape_index % tapes_needed
            db.execute("UPDATE tapes SET tapeset_idx=#{tape_index_in_set} WHERE label=\"#{free_tapes[tape_index][1]}\"")
            report.tape_updated(free_tapes[tape_index][1])

            tape_contents[tape_index_in_set].each() do |file|
                db.execute("INSERT INTO links (file_number, tape_number, tapeset_number) VALUES (#{file[0]}," +
                    " #{free_tapes[tape_index][0]}, #{set_number})")
                report.link_added(file[4], free_tapes[tape_index][1], tapeset_names[set])
            end

            tapes_used << free_tapes[tape_index][1]

            tape_index += 1
        end
    end

    # 6. List info about new used tapes.
    report.msg('Tapeset(s) created:')
    tape_info(db, tapes_used) unless (mods[:quiet])
end

def tapeset_update(db, report, old_name, new_name)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{new_name}\"")
    if (in_db == 0)
        db.execute("UPDATE tapesets SET name=\"#{new_name}\" WHERE name=\"#{old_name}\"")
        report.tapeset_updated(old_name)
    else
        report.error("Tapeset with name #{new_name} already exists in the database.")
    end
end

def tapeset_remove(db, report, names)
    names.each() do |tapeset|
        # First, collect all the information.
        tapeset_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset}\"")

        tapes = db.execute("SELECT DISTINCT links.tape_number, tapes.label FROM links LEFT JOIN tapes ON" +
            " tapes.number=links.tape_number WHERE tapeset_number=#{tapeset_number}")

        files_check = db.execute("SELECT links.file_number, files.path FROM links LEFT JOIN files ON" +
            " files.number=links.file_number WHERE links.tapeset_number=#{tapeset_number} AND files.on_disk=0")
        files_remove = []
        files_check.each() do |file|
            tapeset_count = db.get_first_value("SELECT COUNT(DISTINCT tapeset_number) FROM links WHERE" +
                " file_number=#{file[0]} AND NOT tapeset_number=#{tapeset_number}")
            if (tapeset_count == 0)
                files_remove << file
            end
        end

        links = db.execute("SELECT files.path, tapes.label, tapesets.name FROM links LEFT JOIN files ON" +
            " files.number=links.file_number LEFT JOIN tapes ON tapes.number=links.tape_number LEFT JOIN tapesets" +
            " ON tapesets.number=links.tapeset_number WHERE links.tapeset_number=#{tapeset_number}")

        # Now make the database updates.
        # 1. Delete the tapeset.
        db.execute("DELETE FROM tapesets WHERE number=#{tapeset_number}")
        report.tapeset_removed(tapeset)
        # 2. Update tapes.
        tapes.each() do |tape|
            db.execute("UPDATE tapes SET tapeset_idx=-1, written=NULL, verified=NULL WHERE number=#{tape[0]}")
            report.tape_updated(tape[1])
        end
        # 3. Remove files.
        files_remove.each() do |file|
            db.execute("DELETE FROM files WHERE number=#{file[0]}")
            report.file_removed(file[1])
        end
        # 4. Remove links.
        db.execute("DELETE FROM links WHERE tapeset_number=#{tapeset_number}")
        links.each() do |link|
            report.link_removed(link[0], link[1], link[2])
        end
    end
end

def tapeset_list(db, names_fuzzy)
    query = 'SELECT name FROM tapesets'
    unless (names_fuzzy.empty?())
        query += ' WHERE'
        names_fuzzy.each() do |name|
            query += " name LIKE \"#{name}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY name ASC'
    tapesets = db.execute(query)
    tapesets.collect!() do |tapeset|
        {:name => tapeset[0]}
    end
    tp(tapesets, :name)
end

def tapeset_info(db, names)
    query = 'SELECT DISTINCT tapesets.name, tapesets.tape_count, tapes.label, tapes.tapeset_idx FROM tapesets LEFT' +
        ' JOIN links ON links.tapeset_number=tapesets.number LEFT JOIN tapes ON tapes.number=links.tape_number'
    unless (names.empty?())
        query += ' WHERE'
        names.each() do |name|
            query += " name=\"#{name}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY tapes.label ASC'

    data = db.execute(query)
    data.collect!() do |row|
        {:name => row[0], :tape => row[2], :volume => "#{(row[3] + 1)} / #{row[1]}"}
    end
    tp(data, :name, :tape, :volume)
end

#-----------------------------------------------------------------------------------------------------------------------
# Tar method section

def tar_block_header_checksum_valid?(block)
    bytes = block.unpack('C*')
    cksum_bytes = []
    for i in 0..7
        cksum_bytes << bytes[i + 148]
        bytes[i + 148] = 32
    end
    cksum_in_block = cksum_bytes.pack('CCCCCC').to_i(8)
    cksum_calc = 0
    bytes.each() do |byte|
        cksum_calc += byte
    end
    return cksum_calc == cksum_in_block
end

def tar_block_header_parse(block)
    return {
        :name => block[0..99].strip!(),
        :mode => block[100..107].strip!(),
        :uid => block[108..115].strip!(),
        :gid => block[116..123].strip!(),
        :size => block[124..135].strip!().to_i(8),
        :mtime => block[136..147].strip!().to_i(8),
        :checksum => block[148..155].strip!().to_i(8),
        :link => block[156],
        :link_name => block[157..256].strip!(),
        :ustar => block[257..262].strip!(),
        :ustar_version => block[263..264].to_i(8),
        :owner_user => block[265..296].strip!(),
        :owner_group => block[297..328].strip!(),
        :dev_major_num => block[329..336].strip!().to_i(8),
        :dev_minor_num => block[337..344].strip!().to_i(8),
        :name_prefix => block[345..499].strip!()
    }
end

def tar_verify(report, filename, blocking_factor)
    verified = 0
    incorrect = 0
    unknown = 0

    unless (File.readable?(filename))
        report.error("Can not read file: #{filename}")
        return false
    end
    begin
        file = File.open(filename, 'rb')

        state = :scan
        ext_header = nil
        ext_header_data = ''
        ext_header_file_size = nil
        header = nil
        processed = 0
        sha1 = nil
        digest = nil

        while (true)
            data_block = file.read(blocking_factor * 512)
            break if (data_block.nil?)

            case data_block.length()
            when (blocking_factor * 512)
                # Data block.
                left = data_block.length()
                offset = 0
                while (left > 0)
                    block = data_block[offset..(offset + 511)]

                    case state
                    when :scan
                        if (tar_block_header_checksum_valid?(block))
                            x = tar_block_header_parse(block)
                            if (x[:link] == 'x') # Check for extended header.
                                ext_header = x
                                ext_header_file_size = nil
                                processed = 0
                                state = :ext
                            elsif (x[:link] == '0') # Check for file header.
                                header = x
                                header[:size] = ext_header_file_size unless (ext_header_file_size.nil?())
                                processed = 0
                                digest = Digest::SHA1.new()
                                # Handle the special case of 0-length files in the tarball.
                                if (header[:size] == 0)
                                    calc_sha1 = digest.hexdigest()
                                    if (sha1.nil?())
                                        report.info("#{calc_sha1}  #{header[:name]}")
                                        unknown += 1
                                    else
                                        unless (sha1 == calc_sha1)
                                            report.error("Checksum mismatch: #{calc_sha1} #{header[:name_prefix]}" +
                                                "#{header[:name]}")
                                            incorrect += 1
                                        end
                                    end

                                    verified += 1

                                    state = :scan
                                else
                                    state = :file
                                end
                            end        
                        end
                    when :ext
                        ext_header_data += block
                        processed += 512
                        if (processed >= ext_header[:size])
                            entries = ext_header_data.strip().split("\n")
                            sha1 = nil
                            entries.each() do |entry|
                                if (entry =~ /xattr\.user\.sha1=[0-9a-fA-F]{40}/)
                                    sha1 = entry.match(/[0-9a-fA-F]{40}/).to_s()
                                end
                                if (entry =~ /[0-9]+ size=[0-9]+/)
                                    numbers = entry.scan(/[0-9]+/)
                                    ext_header_file_size = numbers.last().to_i()
                                end
                            end
                            ext_header_data = ''
                            state = :scan
                        end
                    when :file
                        digest_length = [512, (header[:size] - processed)].min()
                        # If block is here to speedupify the digest. No need to copy bytes if full block is digested.
                        if (digest_length != 512)
                            digest.update(block[0..(digest_length - 1)])
                        else
                            digest.update(block)
                        end

                        processed += 512
                        if (processed >= header[:size])
                            calc_sha1 = digest.hexdigest()
                            if (sha1.nil?())
                                report.info("#{calc_sha1}  #{header[:name]}")
                                unknown += 1
                            else
                                unless (sha1 == calc_sha1)
                                    report.error("Checksum mismatch: #{calc_sha1} #{header[:name_prefix]}" +
                                        "#{header[:name]}")
                                    incorrect += 1
                                end
                            end

                            verified += 1

                            state = :scan
                        end
                    end
                    
                    left -= 512
                    offset += 512
                end
            when 0
                # At EOF.
                break
            else
                # Cut off tar.
                report.error('Truncated tar.')
                break
            end
        end

        report.info("Tar verified. Files: #{verified}, Correct: #{verified - incorrect - unknown}, Incorrect:" + 
            " #{incorrect}, Unknown: #{unknown}")
    rescue IOError => e
        report.error(e.to_s())
    ensure
        file.close() if (file)
    end

    return (incorrect == 0)
end

#-----------------------------------------------------------------------------------------------------------------------
# Tool method section

def tool_parse_command_line(exec, mods)
    parser = OptionParser.new() do |options|
        options.separator('')
        options.separator('Mode:')

        # Mode handling.
        options.on('-m mode', '--mode mode', 'Specifies the operational mode. [file, path, tape, tapeset]') do |mode|
            exec[:mode] = mode
        end

        options.separator('')
        options.separator('Modifiers:')

        # Modifiers handling.
        options.on('-v', '--verbose', 'Enables verbose mode.') do ||
            mods[:verbose] = true
        end
        options.on('-q', '--quiet', 'Enables quiet mode. Overrides verbose mode.') do ||
            mods[:quiet] = true
            mods[:verbose] = false
        end
        options.on('-R', '--relative', 'Use relative paths in manifest.') do ||
            mods[:relative] = true
        end
        options.on('-d', '--duplicates', 'Enables duplicates mode.') do ||
            mods[:duplicates] = true
        end
        options.on('-2', '--double', 'Enables double mode. Generates 2 tapesets.') do ||
            mods[:sets] = 2 if (mods[:sets] < 2)
        end
        options.on('-3', '--triple', 'Enables triple mode. Generates 3 tapesets.') do ||
            mods[:sets] = 3 if (mods[:sets] < 3)
        end
        options.on('-D', '--first-fit-decreasing', 'First Fit Decreasing algorithm for packing files on tapes.') do ||
            mods[:ffd] = true
        end
        options.on('-n', '--name name', 'Supplies the name of the tapeset.') do |name|
            mods[:name] = name
        end
        options.on('-A', '--async', 'Database in asynchronous mode. WARNING unsafe if PC crashes or loses power!') do ||
            mods[:async] = true
        end
        options.on('-t', '--tape-device device', 'Selects the tape device for tape operations.') do |device|
            mods[:device] = device
        end
        options.on('-I', '--incremental', 'Selects incremental tapeset mode.') do ||
            mods[:incremental] = true
        end
        options.on('-N', '--no-rewind-offline', 'Instructs to not rewind & eject the tape.') do ||
            mods[:no_rewind] = true
        end

        options.separator('')
        options.separator('Actions:')

        # Actions handling.
        options.on('-a', '--add', 'Adds the specified item.') do ||
            exec[:action] = 'add'
        end
        options.on('-u', '--update', 'Updates the specified item.') do ||
            exec[:action] = 'update'
        end
        options.on('-r', '--remove', 'Removes the specified item.') do ||
            exec[:action] = 'remove'
        end
        options.on('-l', '--list', 'Lists the specified item.') do ||
            exec[:action] = 'list'
        end
        options.on('-i', '--info', 'Displays info about the specified item.') do ||
            exec[:action] = 'info'
        end
        options.on('-M', '--manifest', 'Displays the manifest of the specified tape.') do ||
            exec[:action] = 'manifest'
        end
        options.on('-p', '--prune', 'Prunes the specified item.') do ||
            exec[:action] = 'prune'
        end
        options.on('-c', '--check', 'Checks the specified item.') do ||
            exec[:action] = 'check'
        end
        options.on('-w', '--write', 'Writes the tape.') do ||
            exec[:action] = 'write'
        end
        options.on('-V', '--verify', 'Verifies the tape.') do ||
            exec[:action] = 'verify'
        end
        options.on(nil, '--mark-written', 'Marks the tapes as written.') do ||
            exec[:action] = 'written'
        end
        options.on(nil, '--mark-verified', 'Marks the tapes as verified.') do ||
            exec[:action] = 'verified'
        end
        options.on(nil, '--mark-erased', 'Marks the tapes as erased.') do ||
            exec[:action] = 'erased'
        end

        options.separator('')
        options.separator('Usage:')

        # Show usage if no options specified.
        options.on_tail('-h', '--help', 'Displays this help message.') do || 
            puts(options)
        end
    end
    parser.parse!

    # What is left over at this point are the items (if any).
    exec[:items] = ARGV
end

def tool_validate_command_line(exec, mods, report)
    # If in tape mode, parse items array for possible input from barcode reader.
    if (exec[:mode] == 'tape')
        new_items = []
        exec[:items].each() do |str|
            new_items << str.split('*').reject() do |c| c.empty?() end
        end
        new_items.flatten!()
        unless (new_items == nil)
            new_items.uniq!()
        end
        exec[:items] = new_items
    end

    # Check mode, and if actions are allowed in the mode.
    illegal = { \
        'file' => %w[manifest prune written verified erased write verify], \
        'path' => %w[manifest written verified erased write verify], \
        'tape' => %w[prune check], \
        'tapeset' => %w[manifest prune check written verified erased write verify] \
    }
    if (illegal[exec[:mode]] == nil)
        report.error("Unsupported mode #{exec[:mode]} specified.")
        return false
    elsif (illegal[exec[:mode]].include?(exec[:action]))
        report.error("Mode #{exec[:mode]} cannot be combined with action #{exec[:action]}.")
        return false
    end

    # Check action.
    legal = %w[add update remove list info manifest prune check written verified erased write verify]
    unless (legal.include?(exec[:action]))
        report.error("Unsupported action #{exec[:action]} specified.")
        return false
    end

    # Check if correct number of items is specified.
    min = ((exec[:action] == 'list') || (exec[:action] == 'info')) ? 0 : 1
    max = ((exec[:action] == 'update') && ((exec[:mode] == 'tape') || (exec[:mode] == 'tapeset'))) ? 1 : -1
    case exec[:action]
    when 'write', 'verify'
        max = 1
    end
    if (exec[:items].length() < min)
        report.error("At least #{min} items must be specified.")
        return false
    end
    if (max > -1) && (exec[:items].length() > max)
        report.error("Maximum #{max} items may be specified.")
        return false
    end

    # Items do not need to be checked when running list action (fuzzy input allowed.)
    unless(exec[:action] == 'list')
        # Check if all items are valid files if in file mode.
        if (exec[:mode] == 'file')
            exec[:items].each() do |file|
                unless (File.file?(file))
                    report.error("Incorrect file name: #{file}")
                    return false
                end
            end
        end

        # Check if all items are valid paths if in path mode. (or when adding in tapeset mode.)
        if ((exec[:mode] == 'path') || ((exec[:mode] == 'tapeset') && (exec[:action] == 'add')))
            exec[:items].each() do |path|
                unless (File.directory?(path))
                    report.error("Incorrect path name: #{path}")
                    return false
                end
            end
        end

        # Check if all items are valid tapes if in tape mode.
        if (exec[:mode] == 'tape')
            exec[:items].each() do |label|
                unless (tape_valid_label?(label))
                    report.error("Incorrect tape label: #{label}")
                    return false
                end
            end
        end
    end

    # Check if device is set properly when in tape mode and scripts is selected.
    actions = %w[write verify]
    if ((exec[:mode] == 'tape') && (actions.include?(exec[:action])))
        if (mods[:device].empty?())
            report.error('No tape streamer device specified.')
            return false
        end
        unless (File.readable?(mods[:device]) && File.writable?(mods[:device]))
            report.error("Invalid tape streamer device specified : #{mods[:device]}.")
            return false
        end
    end

    # Check target name if renaming a tape.
    if ((exec[:mode] == 'tape') && (exec[:action] == 'update'))
        unless (tape_valid_label?(mods[:name]))
            report.error("Invalid tape name specified: #{mods[:name]}.")
        end
    end

    # All is OK!
    return true
end

#-----------------------------------------------------------------------------------------------------------------------
# Main section

begin
    # Initialize variables
    version = 2
    db_version = 2
    exec = {:mode => '', :action => '', :items => []}
    mods = {:verbose => false, :quiet => false, :relative => false, :duplicates => false, :sets => 1, :ffd => true, 
        :name => '', :async => false, :device => '', :incremental => false}
    db = nil
    
    # Parse and validate command line.
    tool_parse_command_line(exec, mods)
    report = Report.new(mods)

    # Run tool if no error.
    if (tool_validate_command_line(exec, mods, report))
        # Startup banner.
        report.tool_init(version, db_version)

        # Initialize the database.
        #db = db_init(report, version, db_version, mods[:async], DbWrapper.new())
        db = db_init(report, version, db_version, mods[:async])

        # Handle file mode.
        if (exec[:mode] == 'file')
            case exec[:action]
            when 'add'
                file_add(db, report, exec[:items])
            when 'update'
                file_update(db, report, exec[:items])
            when 'remove'
                file_remove(db, report, exec[:items])
            when 'list'
                file_list(db, exec[:items])
            when 'info'
                file_info(db, exec[:items])
            when 'check'
                file_check(db, report, exec[:items])
            end
        end

        if (exec[:mode] == 'path')
            case exec[:action]
            when 'add'
                path_add(db, report, exec[:items])
            when 'update'
                path_update(db, report, exec[:items])
            when 'remove'
                path_remove(db, report, exec[:items])
            when 'list'
                path_list(db, exec[:items])
            when 'info'
                path_info(db, exec[:items])
            when 'prune'
                path_prune(db, report, exec[:items])
            when 'check'
                path_check(db, report, exec[:items])
            end
        end

        if (exec[:mode] == 'tape')
            case exec[:action]
            when 'add'
                tape_add(db, report, exec[:items])
            when 'update'
                tape_update(db, report, exec[:items][0], mods[:name])
            when 'remove'
                tape_remove(db, report, exec[:items])
            when 'list'
                tape_list(db, exec[:items])
            when 'info'
                tape_info(db, exec[:items])
            when 'manifest'
                tape_manifest(db, report, exec[:items], mods)
            when 'write'
                tape_write(db, report, exec[:items], mods)
            when 'verify'
                tape_verify(db, report, exec[:items], mods)
            when 'written'
                tape_written(db, report, exec[:items])
            when 'verified'
                tape_verified(db, report, exec[:items])
            when 'erased'
                tape_erased(db, report, exec[:items])
            end
        end

        if (exec[:mode] == 'tapeset')
            case exec[:action]
            when 'add'
                tapeset_add(db, report, exec[:items], mods)
            when 'update'
                tapeset_update(db, report, exec[:items][0], mods[:name])
            when 'remove'
                tapeset_remove(db, report, exec[:items])
            when 'list'
                tapeset_list(db, exec[:items])
            when 'info'
                tapeset_info(db, exec[:items])
            end
        end

        # Final report.
        report.finalize()
    end
rescue SQLite3::Exception => exception
    report.db_exception(exception)
ensure
    db.close() if (db)
end

