#!/usr/bin/ruby

# Copyright 2018-2020 Erik Van Hamme (erik.vanhamme@gmail.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may NOT use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'digest/sha1'
require 'find'
require 'sqlite3'

#----------------------------------------------------------------------------------------------------------------------
# Helpers
#----------------------------------------------------------------------------------------------------------------------

module CC
    BLACK = 30
    RED = 31
    GREEN = 32
    YELLOW = 33
    BLUE = 34
    MAGENTA = 35
    CYAN = 36
    WHITE = 37
    BRIGHT_BLACK = 90
    BRIGHT_RED = 91
    BRIGHT_GREEN = 92
    BRIGHT_YELLOW = 93
    BRIGHT_BLUE = 94
    BRIGHT_MAGENTA = 95
    BRIGHT_CYAN = 96
    BRIGHT_WHITE = 97
end

class String
    def color(fg, bg = nil)
        if (bg.nil?())
            return "\e[#{fg}m#{self}\e[0m"
        else
            return "\e[#{fg};#{bg + 10}m#{self}\e[0m"
        end
    end

    def to_ws(width)
        l = length()
        if (l < width)
            # Grow.
            return self + (' ' * (width - l))
        elsif (l > width)
            # Shrink.
            if (width > 3)
                return self[0..(width - 4)] + '...'
            else
                return self[0..(width - 1)]
            end
        else
            return self
        end
    end
end

class Array
    def keys()
        k = []
        for i in 0..(length() - 1)
            k << i
        end
        return k
    end
end

def table(data, columns = nil, widths = nil, hide_table = false)
    # Assemble the columns from the data unless given.
    if (columns.nil?())
        columns = []
        data.each() do |row|
            columns << row.keys()
        end
        columns.flatten!().uniq!()
    end

    # Calculate the wanted column lengths from the data.
    lengths = Array.new(columns.length(), 0)
    strings = []
    col_idx = 0
    columns.each() do |col|
        l = col.to_s().length()
        if (lengths[col_idx] < l)
            lengths[col_idx] = l
        end
        col_idx += 1
    end
    data.each() do |row|
        col_idx = 0
        columns.each() do |col|
            s = row[col].to_s()
            l = s.length()

            if (lengths[col_idx] < l)
                lengths[col_idx] = l
            end

            strings << s

            col_idx += 1
        end
    end

    # Deal with maximum widths if provided.
    unless (widths.nil?())
        col_idx = 0
        columns.each() do |col|
            unless (widths[col].nil?())
                lengths[col_idx] = widths[col]
            end
            col_idx += 1
        end
    end

    # Print the table header.
    unless (hide_table)
        header = ''
        line = ''
        col_idx = 0
        columns.each() do |col|
            header += col.to_s().upcase().to_ws(lengths[col_idx]) + ' | '
            line += ('-' * lengths[col_idx]) + '-+-'
            col_idx += 1
        end
        header.chomp!(' | ')
        line.chomp!('-+-')
        puts header
        puts line
    end

    # Print the table data.
    separator = hide_table ? '' : ' | '
    idx = 0
    data.length().times() do | |
        row_string = ''
        col_idx = 0
        columns.length().times() do | |
            row_string += strings[idx].to_ws(lengths[col_idx]) + separator
            col_idx += 1
            idx += 1
        end
        row_string.chomp!(separator)
        puts row_string
    end
end

def sha1(absolute_path)
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    return sha1.hexdigest()
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L1'
        size = 100000000000
    when 'L2'
        size = 200000000000
    when 'L3'
        size = 400000000000
    when 'L4'
        size = 800000000000
    when 'L5'
        size = 1500000000000
    when 'L6'
        size = 2500000000000
    when 'L7'
        size = 6000000000000
    when 'L8'
        size = 12000000000000
    when 'M8'
        size = 9000000000000
    end
    return size
end

def update_fileset_path(db, fileset_number, path)
    fileset_name = db.get_first_value("SELECT name FROM filesets WHERE number=#{fileset_number}")

    # Step 1: Collect data and store it in memory for performance on big filesets.
    files = {}
    files_db = db.execute("SELECT number, path, size, mtime, on_disk FROM files WHERE path LIKE \"#{path}%\"")
    files_db.each() do |file|
        if (files[file[1]].nil?())
            files[file[1]] = []
        end

        files[file[1]] << { :number => file[0], :size => file[2], :mtime => file[3], :on_disk => file[4] }
    end

    links = {}
    links_db = db.execute("SELECT file_number, fileset_number FROM file_fileset_links WHERE fileset_number=" +
        "#{fileset_number}")
    links_db.each() do |link|
        links[link[0]] = link[1]
    end

    # Step 2: Go through filesystem and check each file if it must be added or updated.
    Find.find(path) do |filename|
        if (File.file?(filename))
            filesize = File.size(filename)
            mtime = File.mtime(filename).to_i()

            # Check if a matching file is in the database.
            number = nil
            variants = files[filename]
            variants.each() do |variant|
                if ((variant[:size] == filesize) && (variant[:mtime] == mtime))
                    number = variant[:number]
                    break
                end
            end unless (variants.nil?())

            if (number.nil?())
                sha1 = sha1(filename)

                # File is not in DB with current mtime and size. Check if a matching path exists that is not in a 
                # tarball.
                update_number = db.get_first_value("SELECT number FROM files LEFT JOIN file_tarball_links ON " +
                    "file_number=number WHERE path=\"#{filename}\" AND tarball_number IS NULL")

                if (update_number.nil?())
                    # Nothing to update, add it.
                    ret = db.execute("INSERT INTO files(path, sha1, mtime, size, on_disk) VALUES(\"#{filename}\", " +
                        "\"#{sha1}\", #{mtime}, #{filesize}, 1)")
                    puts("Added file #{filename} to database.".color(CC::BLUE))
                else
                    # Update file with matching path that is not in tarball.
                    db.execute("UPDATE files SET sha1=\"#{sha1}\", mtime=#{mtime}, size=#{filesize}, on_disk = 1 " +
                        " WHERE number=#{update_number}")
                    puts("Updated file #{filename} in database.".color(CC::BLUE))
                end

                number = db.get_first_value("SELECT number FROM files WHERE size=#{filesize} AND mtime=#{mtime} AND " +
                    "path=\"#{filename}\"")
            end

            # Check if properly linked.
            link = links[number]
            if (link.nil?())
                db.execute("INSERT INTO file_fileset_links (file_number, fileset_number) VALUES(#{number}, " +
                    "#{fileset_number})")
                puts("Added file #{filename} to fileset #{fileset_name}.".color(CC::BLUE))
            end
        end
    end

    # Step 3: Remove files in database that are no longer on disk and are not in a (relevant) tarball.
    files_to_consider = db.execute("SELECT number, path, on_disk FROM files LEFT JOIN file_fileset_links ON " +
        "file_fileset_links.file_number=files.number WHERE fileset_number=#{fileset_number}")
    files_to_consider.each() do |file_to_consider|
        unless (File.exists?(file_to_consider[1]))
            # Check if this file appears in a tarball linked to this fileset.
            # If file is not in any relevant tarball(s). Unlink from fileset.
            in_tarballs = db.get_first_value("SELECT COUNT(*) FROM file_tarball_links WHERE " +
                "file_number=#{file_to_consider[0]} AND tarball_number IN (SELECT tarballs.number FROM tarballs " +
                "LEFT JOIN tapes ON tapes.number=tarballs.tape_number LEFT JOIN backups ON " +
                "backups.number=tapes.backup_number WHERE fileset_number=#{fileset_number})")
            if (in_tarballs == 0)
                db.execute("DELETE FROM file_fileset_links WHERE file_number=#{file_to_consider[0]} AND " +
                    "fileset_number=#{fileset_number}")
                puts("Removed file #{file_to_consider[1]} from fileset #{fileset_name}.".color(CC::BLUE))
            end

            # Check if this file appears in any other tarball.
            # If not, remove the file from the database.
            # If yes, mark as not on disk.
            in_tarballs = db.get_first_value("SELECT COUNT(*) FROM file_tarball_links WHERE " +
                "file_number=#{file_to_consider[0]}")
            if (in_tarballs == 0)
                db.execute("DELETE FROM files WHERE number=#{file_to_consider[0]}")
                puts("Removed file #{file_to_consider[1]} from database.".color(CC::BLUE))
            else
                if (file_to_consider[2] != 0)
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_to_consider[0]}")
                    puts("Marked file #{file_to_consider[1]} as not on disk.".color(CC::BLUE))
                end
            end
        end
    end
end

#----------------------------------------------------------------------------------------------------------------------
# Operations
#----------------------------------------------------------------------------------------------------------------------

def add_backup(db, args)
    if (args.length != 2)
        puts('Usage: --add-backup NAME FILESET'.color(CC::RED))
        return
    end

    name = args[0]
    if (db.get_first_value("SELECT COUNT(*) FROM backups WHERE name=\"#{name}\"") > 0)
        puts("Backup with name #{name} is already in the database.".color(CC::RED))
        return
    end

    fileset_name = args[1]
    if (db.get_first_value("SELECT COUNT(*) FROM filesets WHERE name=\"#{fileset_name}\"") == 0)
        puts("Fileset with name #{fileset_name} is not in the database.".color(CC::RED))
        return
    end

    fileset_number = db.get_first_value("SELECT number FROM filesets WHERE name=\"#{fileset_name}\"")

    db.execute("INSERT INTO backups(name, fileset_number) VALUES(\"#{name}\", #{fileset_number})")
    puts('Backup added.'.color(CC::GREEN))
end

def add_fileset(db, args)
    if (args.length() < 2)
        puts('Usage: --add-fileset NAME PATH...'.color(CC::RED))
        return
    end

    name = args[0]
    if (db.get_first_value("SELECT COUNT(*) FROM filesets WHERE name=\"#{name}\"") > 0)
        puts("Fileset with name #{name} is already in the database.".color(CC::RED))
        return
    end

    paths = args[1..(args.length() - 1)]
    paths.each() do |path|
        unless (File.directory?(path))
            puts("Given path #{path} is not an existing directory.".color(CC::RED))
            return
        end
    end

    db.execute("INSERT INTO filesets(name) VALUES(\"#{name}\")")
    fileset_number = db.get_first_value("SELECT number FROM filesets WHERE name=\"#{name}\"")

    paths.each() do |path|
        absolute_path = File.expand_path(path)
        db.execute("INSERT INTO paths(fileset_number, path) VALUES(#{fileset_number}, \"#{absolute_path}\")")
        update_fileset_path(db, fileset_number, absolute_path)
    end
end

def add_paths(db, args)
    if (args.length() < 2)
        puts('Usage: --add-paths NAME PATH...'.color(CC::RED))
        return
    end

    fileset_name = args[0]
    fileset_number = db.get_first_value("SELECT number FROM filesets WHERE name=\"#{fileset_name}\"")
    if (fileset_number.nil?())
        puts("Fileset with name #{fileset_name} is not in the database.".color(CC::RED))
        return
    end

    paths = args[1..(args.length() - 1)]
    paths.each() do |path|
        unless (File.directory?(path))
            puts("Given path #{path} is not an existing directory.".color(CC::RED))
            return
        end
    end

    paths.each() do |path|
        absolute_path = File.expand_path(path)
        db.execute("INSERT INTO paths(fileset_number, path) VALUES(#{fileset_number}, \"#{absolute_path}\")")
        update_fileset_path(db, fileset_number, path)
    end
end

def add_tapes(db, args)
    if (args.length() < 2)
        puts('Usage: --add-tapes NAME LABEL...'.color(CC::RED))
        return
    end

    backup_name = args[0]
    backup_number = db.get_first_value("SELECT number FROM backups WHERE name=\"#{backup_name}\"")
    if (backup_number.nil?())
        puts("Backup with name #{backup_name} is not in the database.".color(CC::RED))
        return
    end

    tape_labels = args[1..(args.length() - 1)]

    tape_idx = db.get_first_value("SELECT MAX(idx) FROM tapes WHERE backup_number=#{backup_number}")
    if (tape_idx.nil?())
        tape_idx = 0
    else
        tape_idx += 1
    end
    
    added = 0

    tape_labels.each() do |tape_label|
        unless ((tape_label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (tape_label =~ /[A-Z0-9]{6}M8/))
            puts("Tape label #{tape_label} is not valid.".color(CC::RED))
            next
        end

        if (db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{tape_label}\"") > 0)
            puts("Tape with label #{tape_label} is already in the database.".color(CC::RED))
            next
        end

        size = tape_size(tape_label)
        db.execute("INSERT INTO tapes(backup_number, label, size, full, idx) VALUES(#{backup_number}, " +
            "\"#{tape_label}\", #{size}, 0, #{tape_idx})")

        tape_idx += 1
        added += 1
    end

    puts("Added #{added} tapes to backup set #{backup_name}.".color(CC::GREEN))
end

def list_backups(db)
    puts('List of backups:'.color(CC::YELLOW))
    data = db.execute('SELECT backups.number, backups.name, filesets.name FROM backups LEFT JOIN filesets ON ' +
        'filesets.number=backups.fileset_number ORDER BY backups.name ASC')
    data.collect!() do |row|
        {:number => row[0], :backup_name => row[1], :fileset_name => row[2]}
    end
    table(data)
end

def list_filesets(db)
    puts('List of filesets:'.color(CC::YELLOW))
    data = db.execute('SELECT number, name FROM filesets ORDER BY name ASC')
    data.collect!() do |row|
        {:number => row[0], :fileset_name => row[1]}
    end
    table(data)
end

def list_tapes(db)
    puts('List of tapes:'.color(CC::YELLOW))
    data = db.execute('SELECT tapes.number, label, size, full, idx, name FROM tapes LEFT JOIN backups ON ' +
        'backups.number=tapes.backup_number ORDER BY name, idx ASC')
    data.collect!() do |row|
        {:number => row[0], :label => row[1], :size => row[2], :full => row[3], :backup_name => row[5], :idx => row[4]}
    end
    table(data)
end

def list_tarballs(db)
    puts('List of tarballs:'.color(CC::YELLOW))
    data = db.execute('SELECT tarballs.number, tarballs.idx, tarballs.size, files, overhead, written, tapes.label, ' +
        'backups.name FROM tarballs LEFT JOIN tapes ON tapes.number=tarballs.tape_number LEFT JOIN backups ON ' +
        'backups.number=tapes.backup_number ORDER BY backups.name, label, tarballs.idx ASC')
    data.collect!() do |row|
        w = Time.at(row[5]).to_s()
        {:number => row[0], :size => row[2], :files => row[3], :overhead => row[4], :written => w, :backup => row[7], 
            :tape => row[6], :idx => row[1]}
    end
    table(data)
end

def manifest(db, args)
    if (args.length() != 1)
        puts('Usage: --manifest LABEL')
    end

    tape_label = args[0]

    if (db.execute("SELECT COUNT(*) FROM tapes WHERE label=\"#{tape_label}\"") == 0)
        puts("Tape with label #{tape_label} is not in the database.".color(CC::RED))
        return
    end

    tape = db.get_first_row("SELECT tapes.label, tapes.size, tapes.full, tapes.idx, backups.name, tapes.number FROM " +
        "tapes LEFT JOIN backups ON backups.number=tapes.backup_number WHERE label=\"#{tape_label}\"")
    tape_number = tape[5]

    tarballs = db.execute("SELECT number, idx, size, files, overhead, written FROM tarballs WHERE " +
        "tape_number=#{tape_number}")

    puts("Begin tape #{tape[0]} manifest:".color(CC::BLUE))
    puts("    Tape is has index #{tape[3]} in backup set #{tape[4]}.".color(CC::BLUE))
    puts("    Tape has a size of #{tape[1]} and is #{tape[2] == 0 ? 'not ' : ''}full.".color(CC::BLUE))
    puts(("    There #{tarballs.length() == 1? 'is' : 'are'} #{tarballs.length()} " +
        "tarball#{tarballs.length() == 1 ? '' : 's'} on the tape.").color(CC::BLUE))

    total_size = 0

    tarballs.each() do |tarball|
        puts("Tarball #{tarball[1]} written at #{Time.at(tarball[5])} contains #{tarball[3]} files.".color(CC::MAGENTA))
        puts(("Tarball has a total size of #{tarball[2]} bytes with an observed overhead of #{tarball[4]} " +
            "bytes.").color(CC::MAGENTA))
        puts('File list:'.color(CC::MAGENTA))

        files = db.execute("SELECT files.path, files.size FROM files LEFT JOIN file_tarball_links ON " +
            "file_tarball_links.file_number=files.number WHERE tarball_number=#{tarball[0]}")

        files.each() do |file|
            puts("    #{file[0]} (#{file[1]} bytes)".color(CC::CYAN))
        end

        total_size += tarball[2]
    end

    puts("Total data size on tape is #{total_size} bytes.".color(CC::BLUE))
    puts("End tape #{tape[0]} manifest.".color(CC::BLUE))
end

def remove_backups(db, backups)
    backups.each() do |backup|
        backup_number = db.get_first_value("SELECT number FROM backups WHERE name=\"#{backup}\"")
        if (backup_number.nil?())
            puts("Backup with name #{backup} is not in the database.".color(CC::RED))
            next
        else
            # 1. Remove tapes in the backup.
            tape_labels = db.execute("SELECT label FROM tapes WHERE backup_number=#{backup_number}")
            remove_tapes(db, tape_labels.flatten())

            # 2. Remove backup.
            db.execute("DELETE FROM backups WHERE number=#{backup_number}")
            puts("Backup with name #{backup} has been deleted from database.".color(CC::BLUE))
        end
    end
end

def remove_tapes(db, tapes)
    tapes.each() do |tape|
        tape_number = db.get_first_value("SELECT number FROM tapes WHERE label=\"#{tape}\"")
        if (tape_number.nil?())
            puts("Tape with label #{tape} is not in the database.".color(CC::RED))
            next
        else
            tarball_numbers = db.execute("SELECT number FROM tarballs WHERE tape_number=#{tape_number}")
            tarball_numbers.each() do |tarball_number|
                # 1. Delete the file links
                db.execute("DELETE FROM file_tarball_links WHERE tarball_number=#{tarball_number[0]}")

                # 2. Delete tarball
                db.execute("DELETE FROM tarballs WHERE number=#{tarball_number[0]}")
            end

            db.execute("DELETE FROM tapes WHERE number=#{tape_number}")
            puts("Tape with label #{tape} has been deleted from database.".color(CC::BLUE))
        end
    end
end

def restore(db, args)
    # TODO: Implement me.
end

def usage()
    puts("Usage:")
    # TODO: Implement me.
end

def summary(db)
    backups = db.execute("SELECT number, fileset_number, name FROM backups ORDER BY name ASC")

    backups.each() do |backup|
        number, fileset_number, name = backup

        puts("Backup set #{name}:".color(CC::BLUE))
        fileset_file_sizes = db.execute("SELECT size FROM files LEFT JOIN file_fileset_links ON " +
            "file_fileset_links.file_number=files.number WHERE fileset_number=#{fileset_number} AND on_disk = 1")
        fileset_size = 0
        fileset_file_sizes.each() do |filesize|
            fileset_size += filesize[0]
        end

        files_not_written = db.execute("SELECT size FROM files LEFT JOIN file_fileset_links ON " +
            "file_fileset_links.file_number=files.number WHERE file_fileset_links.fileset_number=#{fileset_number} " +
            "AND on_disk = 1 AND number NOT IN (SELECT files.number FROM files LEFT JOIN file_tarball_links ON " +
            "file_tarball_links.file_number=files.number LEFT JOIN tarballs ON " +
            "tarballs.number=file_tarball_links.tarball_number LEFT JOIN tapes ON tapes.number=tarballs.tape_number " +
            "LEFT JOIN backups ON backups.number=tapes.backup_number WHERE backup_number=#{number})")
        if (files_not_written.length() == 0)
            puts("  Status: All files of the fileset are on tapes in the backup set.".color(CC::GREEN))
        else
            unwritten_size = 0
            files_not_written.each() do |filesize|
                unwritten_size += filesize[0]
            end
            puts(("  Status: There are #{files_not_written.length()} files not on tape in the backup set for a size " +
                "of #{unwritten_size} bytes.").color(CC::RED))
        end

        fileset_name = db.get_first_value("SELECT name FROM filesets WHERE number=#{fileset_number}")
        puts(("  Fileset #{fileset_name} stores #{fileset_file_sizes.length()} files for a total size of " +
            "#{fileset_size} bytes:").color(CC::CYAN))

        paths = db.execute("SELECT path FROM paths WHERE fileset_number=#{fileset_number}")
        paths.each() do |path|
            puts("    Path #{path[0]}".color(CC::CYAN))
        end

        tapes = db.execute("SELECT number, label, size, full, idx FROM tapes WHERE backup_number=#{number} ORDER BY " +
            "idx ASC")
        tapes.each() do |tape|
            tape_number, label, size, full, idx = tape
            puts(("  Tape #{idx} labeled #{label} with size #{size} " +
                "[#{full == 1 ? 'FULL' : 'NOT FULL'}]:").color(CC::MAGENTA))

            tarballs = db.execute("SELECT idx, size, files, overhead, written FROM tarballs WHERE " +
                "tape_number=#{tape_number} ORDER BY idx ASC")
            tarballs.each() do |tarball|
                idx, size, files, overhead, written = tarball

                puts(("    Tarball #{idx} stores #{files} files in #{size} bytes with #{overhead} bytes of " +
                    "overhead.").color(CC::YELLOW))
                puts("      Written at #{Time.at(written)}.".color(CC::YELLOW))
            end
        end
    end unless (backups.nil?())
end

def update_filesets(db, args)
    args.each() do |fileset_name|
        fileset_number = db.get_first_value("SELECT number FROM filesets WHERE name=\"#{fileset_name}\"")
        paths = db.execute("SELECT path FROM paths WHERE fileset_number=#{fileset_number}")
        paths.each() do |path|
            update_fileset_path(db, fileset_number, path[0])
        end unless (paths.nil?())
        puts("Fileset #{fileset_name} updated.".color(CC::GREEN))
    end unless (args.nil?())
end

def write(db, args)
    backup_name = args[0]
    device = args[1]

    # TODO: Validation of arguments.

    data = db.get_first_row("SELECT number, fileset_number FROM backups WHERE name=\"#{backup_name}\"")
    backup_number = data[0]
    fileset_number = data[1]

    tape = db.get_first_row("SELECT number, label FROM tapes WHERE backup_number=#{backup_number} AND full=0 ORDER BY " +
        "label ASC")
    if (tape.nil?())
        puts("There are no tapes available in backup set #{backup_name}.".color(CC::RED))
        return
    end
    tape_number = tape[0]

    files_to_consider = db.execute("SELECT number, path, size FROM files LEFT JOIN file_fileset_links ON " +
        "file_fileset_links.file_number=files.number WHERE file_fileset_links.fileset_number=#{fileset_number} AND " +
        "on_disk = 1 AND number NOT IN (SELECT files.number FROM files LEFT JOIN file_tarball_links ON " +
        "file_tarball_links.file_number=files.number LEFT JOIN tarballs ON " +
        "tarballs.number=file_tarball_links.tarball_number LEFT JOIN tapes ON tapes.number=tarballs.tape_number " +
        "LEFT JOIN backups ON backups.number=tapes.backup_number WHERE backup_number=#{backup_number}) ORDER BY path " +
        "ASC")

    files_to_write = []
    files_to_consider.each() do |file|
        if (File.exists?(file[1]))
            files_to_write << file
        else
            puts('There are files labeled as on disk that do not exist. Update the fileset first.'.color(CC::RED))
            return
        end
    end

    if (files_to_write.length() == 0)
        puts('There are no files to be written in this backup set.'.color(CC::GREEN))
        return
    end

    puts("Started write at #{Time.now().to_s()}.".color(CC::MAGENTA))

    tarball_index = db.get_first_value("SELECT MAX(idx) FROM tarballs WHERE tape_number=#{tape_number}")
    if (tarball_index.nil?())
        tarball_index = 0
    else
        tarball_index += 1
    end

    # Set correct blocksize.
    block_size = 8192 * 512 # 4MB blocks.
    result = `mt-st -f #{device} setblk #{block_size} 2>&1`
    unless ($?.success?())
        puts("Could not set blocksize: mt-st error: #{result}".color(CC::RED))
        return
    end

    # Enable compression.
    result = `mt-st -f #{device} compression 1 2>&1`
    unless ($?.success?())
        puts("Could not set enable compression: mt-st error: #{result}".color(CC::RED))
        return
    end

    # Advance the tape to the correct file record.
    if (tarball_index > 0)
        result = `mt-st -f #{device} fsf #{tarball_index} 2>&1`
        unless ($?.success?())
            puts("Could not advance tape to correct file record: mt-st error: #{result}".color(CC::RED))
            return            
        end
    end

    begin
        filelist = File.open('filelist.txt', 'wb')

        files_to_write.each() do |file|
            relative_filename = file[1].sub(/^\//, '')

            filelist.puts(relative_filename)
        end

        filelist.close()

        error = false
        full = false
        bytes_written = 0
        result = `tar -H pax -b 8192 -cf #{device} -C / -T filelist.txt --totals 2>&1`
        success = $?.success?()
        lines = result.split("\n")
        lines.each() do |line|
            if (line =~ /Total bytes written/)
                bytes_written = line.match(/[0-9]+/).to_s().to_i()
            end

            if (line =~ /No space left on device/)
                full = true
            end

            if (line =~ /tar\: Error/)
                error = true
            end
        end

        if ((error == true) && (full == false))
            # Genuine error! report it.
            lines.each() do |line|
                puts(line.color(CC::RED))
            end
            return
        end
    rescue IOError => e
        puts("Could not write filelist due to IOError: #{e.to_s()}.")
        return
    ensure
        filelist.close() unless (filelist.nil?())
        File.delete('filelist.txt')
    end

    if (full)
        # Determine how far we got if the tape was full.
        files_written = []
        sum = 0
        files_to_write.each() do |file|
            size = file[2]
            ws = (3 * 512) + size + (size % 512)
            if ((sum + ws) < bytes_written)
                files_written << file
                sum += ws
            else
                break
            end
        end
    else
        # If the tape was not full, all files have been written.
        files_written = files_to_write
    end

    file_size = 0
    files_written.each() do |file|
        file_size += file[2]
    end
    
    overhead = bytes_written - file_size

    db.execute("INSERT INTO tarballs(tape_number, idx, size, files, overhead, written) VALUES(#{tape_number}, " +
        "#{tarball_index}, #{file_size}, #{files_written.length()}, #{overhead}, #{Time.now().to_i()})")

    tarball_number = db.get_first_value("SELECT number FROM tarballs WHERE tape_number=#{tape_number} AND " +
        "idx=#{tarball_index}")

    files_written.each() do |file|
        db.execute("INSERT INTO file_tarball_links(file_number, tarball_number) VALUES(#{file[0]}, #{tarball_number})")
    end

    if (full)
        db.execute("UPDATE tapes SET full=1 WHERE number=#{tape_number}")
    end

    # Rewind.
    result = `mt-st -f #{device} rewind 2>&1`
    unless ($?.success?())
        puts("Could not rewind: mt-st error: #{result}".color(CC::RED))
        return
    end

    puts("Finished write at #{Time.now().to_s()}.".color(CC::MAGENTA))

    puts("Tarball written. #{files_written.length()} files backed up.".color(CC::GREEN))
end

#----------------------------------------------------------------------------------------------------------------------
# Main
#----------------------------------------------------------------------------------------------------------------------

begin
    db = SQLite3::Database.new('bu.db')

    if (db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"').empty?())
        # Create new db.
        db.execute('CREATE TABLE files(number INTEGER PRIMARY KEY, path TEXT NOT NULL, sha1 TEXT NOT NULL, mtime ' +
            'INTEGER NOT NULL, size INTEGER NOT NULL, on_disk INTEGER NOT NULL)')
        db.execute('CREATE TABLE filesets(number INTEGER PRIMARY KEY, name TEXT NOT NULL)')
        db.execute('CREATE TABLE file_fileset_links(file_number INTEGER NOT NULL, fileset_number INTEGER NOT NULL)')
        db.execute('CREATE TABLE backups(number INTEGER PRIMARY KEY, fileset_number INTEGER NOT NULL, name TEXT NOT ' +
            'NULL)')
        db.execute('CREATE TABLE paths(number INTEGER PRIMARY KEY, fileset_number INTEGER NOT NULL, path TEXT NOT ' +
            'NULL)')
        db.execute('CREATE TABLE tapes(number INTEGER PRIMARY KEY, backup_number INTEGER NOT NULL, label TEXT NOT ' +
            'NULL, size INTEGER NOT NULL, full INTEGER NOT NULL, idx INTEGER NOT NULL)')
        db.execute('CREATE TABLE tarballs(number INTEGER PRIMARY KEY, tape_number INTEGER NOT NULL, idx INTEGER NOT ' +
            'NULL, size INTEGER NOT NULL, files INTEGER NOT NULL, overhead INTEGER NOT NULL, written INTEGER NOT NULL)')
        db.execute('CREATE TABLE version(version INTEGER NOT NULL)')
        db.execute('CREATE TABLE file_tarball_links(file_number INTEGER NOT NULL, tarball_number INTEGER NOT NULL)')
        db.execute('INSERT INTO version(version) values(6)')

        puts('New database created.'.color(CC::YELLOW))
        version = 5
    else
        # Check db version.
        version = db.get_first_value('SELECT version FROM version;')
        if (version != 6)
            puts('Incompatible database version'.color(CC::RED))
            exit(-1)
        end
    end

    puts("Backuptool [tool V5, database V#{version}]".color(CC::CYAN))
    puts("  Copyright 2018-2020 Erik Van Hamme (erik.vanhamme@gmail.com)".color(CC::CYAN))

    args = ARGV

    if (args.length() == 0)
        usage()
        exit(0)
    end

    action = args[0]
    args = args[1..(args.length() - 1)]

    case action
    when '--add-backup'
        add_backup(db, args)
    when '--add-fileset'
        add_fileset(db, args)
    when '--add-paths'
        add_paths(db, args)
    when '--add-tapes'
        add_tapes(db, args)
    when '--list-backups'
        list_backups(db)
    when '--list-filesets'
        list_filesets(db)
    when '--list-tapes'
        list_tapes(db)
    when '--list-tarballs'
        list_tarballs(db)
    when '--manifest'
        manifest(db, args)
    when '--remove-backups'
        remove_backups(db, args)
    # TODO: when '--remove-filesets'
    # TODO: when '--remove-paths'
    when '--remove-tapes'
        remove_tapes(db, args)
    when '--restore'
        restore(db, args)
    when '--summary'
        summary(db)
    when '--update-filesets'
        update_filesets(db, args)
    when '--write'
        write(db, args)
    else
        usage()
        exit(0)
    end

rescue SQLite3::Exception => exception
    puts("SQL exception: #{exception.to_s()}".color(CC::RED))
ensure
    db.close() unless db.nil?()
end
