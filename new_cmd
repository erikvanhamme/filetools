#!/usr/bin/ruby

#-----------------------------------------------------------------------------------------------------------------------
# Class definitions

module CC # COMMON
    BLACK = 30
    RED = 31
    GREEN = 32
    YELLOW = 33
    BLUE = 34
    MAGENTA = 35
    CYAN = 36
    WHITE = 37
    BRIGHT_BLACK = 90
    BRIGHT_RED = 91
    BRIGHT_GREEN = 92
    BRIGHT_YELLOW = 93
    BRIGHT_BLUE = 94
    BRIGHT_MAGENTA = 95
    BRIGHT_CYAN = 96
    BRIGHT_WHITE = 97
end

class String
    def color(fg, bg = nil) # COMMON
        if (bg.nil?())
            return "\e[#{fg}m#{self}\e[0m"
        else
            return "\e[#{fg};#{bg + 10}m#{self}\e[0m"
        end
    end

    def to_ws(width) # COMMON
        l = length()
        if (l < width)
            # Grow.
            return self + (' ' * (width - l))
        elsif (l > width)
            # Shrink.
            if (width > 3)
                return self[0..(width - 4)] + '...'
            else
                return self[0..(width - 1)]
            end
        else
            return self
        end
    end
end

class Array
    def keys() # COMMON
        k = []
        for i in 0..(length() - 1)
            k << i
        end
        return k
    end
end

class Arg # COMMON
    attr_accessor :long, :short, :min_args, :max_args, :args_type, :help

    def initialize(long, short, min_args, max_args, args_type, help)
        @long = long
        @short = short
        @min_args = min_args
        @max_args = max_args
        @args_type = args_type
        @help = help
    end
end

class ReportBase # COMMON
    def configure(verbose, quiet)
        @verbose = verbose
        @quiet = quiet
    end

    def msg(s)
        puts(s) if (@verbose)
    end

    def always(s)
        puts(s)
    end

    def info(s)
        puts(s.color(CC::GREEN)) unless (@quiet)
    end

    def warning(s)
        puts("Warning: #{s}".color(CC::YELLOW()))
    end

    def error(s)
        puts("Error: #{s}".color(CC::RED))
    end

    def time(s, t_time)
        puts("#{s} at #{t_time}.".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def duration(s, t_start, t_end)
        d = t_end - t_start
        fraction = d % 1
        d -= fraction
        fraction = (fraction * 100).round(0)
        seconds = d % 60
        d = (d - seconds) / 60
        minutes = d % 60
        d = (d - minutes) / 60
        hours = d % 60

        d_s = sprintf('%02d:%02d:%02d.%02d', hours, minutes, seconds, fraction)

        puts("#{s} at #{t_end}. Duration was #{d_s} .".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def table(data, columns = nil, widths = nil, hide_table = false)
        # Assemble the columns from the data unless given.
        if (columns.nil?())
            columns = []
            data.each() do |row|
                columns << row.keys()
            end
            columns.flatten!().uniq!()
        end

        # Calculate the wanted column lengths from the data.
        lengths = Array.new(columns.length(), 0)
        strings = []
        col_idx = 0
        columns.each() do |col|
            l = col.to_s().length()
            if (lengths[col_idx] < l)
                lengths[col_idx] = l
            end
            col_idx += 1
        end
        data.each() do |row|
            col_idx = 0
            columns.each() do |col|
                s = row[col].to_s()
                l = s.length()

                if (lengths[col_idx] < l)
                    lengths[col_idx] = l
                end

                strings << s

                col_idx += 1
            end
        end

        # Deal with maximum widths if provided.
        unless (widths.nil?())
            col_idx = 0
            columns.each() do |col|
                unless (widths[col].nil?())
                    lengths[col_idx] = widths[col]
                end
                col_idx += 1
            end
        end

        # Print the table header.
        unless (hide_table)
            header = ''
            line = ''
            col_idx = 0
            columns.each() do |col|
                header += col.to_s().upcase().to_ws(lengths[col_idx]) + ' | '
                line += ('-' * lengths[col_idx]) + '-+-'
                col_idx += 1
            end
            header.chomp!(' | ')
            line.chomp!('-+-')
            puts header
            puts line
        end

        # Print the table data.
        separator = hide_table ? '' : ' | '
        idx = 0
        data.length().times() do ||
            row_string = ''
            col_idx = 0
            columns.length().times() do ||
                row_string += strings[idx].to_ws(lengths[col_idx]) + separator
                col_idx += 1
                idx += 1
            end
            row_string.chomp!(separator)
            puts row_string
        end
    end
end

class DbWrapper # COMMON
    def initialize()
        @db = nil
    end

    def wrap(db)
        @db = db
    end

    def execute(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.execute(sql)
    end

    def get_first_value(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_value(sql)
    end

    def get_first_row(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_row(sql)
    end

    def changes()
        return @db.changes()
    end

    def close()
        @db.close()
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Tool method section

def tool_find_arg_short(args, short) # COMMON
    args.each() do |arg|
        return arg if (arg.short() == short)
    end unless (args.nil?())
    return nil
end

def tool_find_arg_long(args, long) # COMMON
    args.each() do |arg|
        return arg if (arg.long() == long)
    end unless (args.nil?())
    return nil
end

def tool_usage_args(action) # COMMON
    args = ''
    unless (action.nil?())
        action.args_type().each() do |arg|
            args += "#{arg.upcase} "
        end
        args.chomp!(' ')
        args += '...' if (action.max_args() == -1)
        args = "<#{args}>" if ((action.min_args() == 0) && (action.max_args() != 0))
    end
    return args
end

def tool_show_usage(report, banner, actions, modifiers, map) # COMMON
    report.always(banner)
    report.always('=' * banner.length)

    all = []
    all << actions
    all << modifiers
    all.flatten!()

    index = 0
    map.each() do |submap|
        report.always(submap[0])
        report.always('-' * submap[0].length())
        submap[1].each() do |subsubmap|
            report.always(subsubmap[0])
            subsubmap[1].times() do ||
                action = all[index]
                args = tool_usage_args(action)
                short = action.short().nil?() ? '' : action.short()
                long = "#{action.long()} #{args}"

                short = short + (' ' * (10 - short.length()))
                long = long + (' ' * (35 - long.length()))
                report.always(short + long + action.help())

                index += 1
            end
        end
    end
end

def tool_parse_command_line(report, actions, modifiers) # COMMON
    selected_actions = []
    selected_modifiers = []

    delete = []
    ARGV.each() do |arg|
        if (arg.match(/^\-[a-zA-Z0-9]{1}$/))
            # Deal with short action or modifier.
            action = tool_find_arg_short(actions, arg)
            modifier = tool_find_arg_short(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
        if (arg.match(/^\-\-[a-zA-Z0-9\-]{2,}$/))
            # Deal with long action or modifier.
            action = tool_find_arg_long(actions, arg)
            modifier = tool_find_arg_long(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
    end
    delete.each() do |del|
        ARGV.delete_at(ARGV.index(del))
    end

    return selected_actions, selected_modifiers, ARGV
end

def tool_build_modifiers()
    m = []
    m << Arg.new('--verbose'      , '-v', 0, 0, [], 'Run verbosely.')
    m << Arg.new('--quiet'        , '-q', 0, 0, [], 'Run quietly.')
    m << Arg.new('--sql'          , nil , 0, 0, [], 'Shows SQL queries. Useful for debugging.')
    m << Arg.new('--async'        , nil , 0, 0, [], 'Database in async mode. Unsafe if PC unstable or power cut.')

    m << Arg.new('--rewind'       , nil , 0, 0, [], 'Rewinds tape after write or verify.')
    m << Arg.new('--offline'      , nil , 0, 0, [], 'Offlines (ejects) tape after write or verify.')

    m << Arg.new('--double'       , '-2', 0, 0, [], 'Double redundancy for --add-tapeset.')
    m << Arg.new('--triple'       , '-3', 0, 0, [], 'Triple redundancy for --add-tapeset.')
    m << Arg.new('--incremental'  , '-i', 0, 0, [], 'Incremental tapeset creation for --add-tapeset.')
    m << Arg.new('--ffd'          , nil , 0, 0, [], 'First Fit Decreasing bin packing for --add-tapeset.')
    m << Arg.new('--no-tape-level', nil , 0, 0, [], 'Fill tape to max instead of leveling for --add-tapeset.')
    return m
end

def tool_build_actions()
    a = []
    a << Arg.new('--help'           , '-h', 0,  0, []               , 'Displays this help.')

    a << Arg.new('--add-paths'      , nil , 1, -1, [:path]          , 'Adds paths to database.')
    a << Arg.new('--update'         , nil , 1, -1, [:path]          , 'Updates paths in database.')
    a << Arg.new('--remove-paths'   , nil , 1, -1, [:path]          , 'Removes paths from database.')
    a << Arg.new('--prune'          , nil , 1, -1, [:path]          , 'Checks database paths for removed files.')
    a << Arg.new('--check-paths'    , nil , 1, -1, [:path]          , 'Checks database paths for duplicates.')

    a << Arg.new('--add-tapes'      , nil , 1, -1, [:label]         , 'Adds tapes to database.')
    a << Arg.new('--remove-tapes'   , nil , 1, -1, [:label]         , 'Removes tapes from database.')
    a << Arg.new('--list-tapes'     , nil , 0, -1, [:searchterm]    , 'Lists tapes in database.')
    a << Arg.new('--info-tapes'     , nil , 0, -1, [:label]         , 'Shows info about tapes in database.')
    a << Arg.new('--manifest'       , nil , 1,  1, [:label]         , 'Shows the files on a tape.')
    a << Arg.new('--mark-erased'    , nil , 1, -1, [:label]         , 'Marks tapes as erased.')
    a << Arg.new('--mark-written'   , nil , 1, -1, [:label]         , 'Marks tapes as written.')
    a << Arg.new('--mark-verified'  , nil , 1, -1, [:label]         , 'Marks tapes as verified.')
    a << Arg.new('--erase'          , nil , 2,  2, [:label, :device], 'Erases the tape on the device.')
    a << Arg.new('--write'          , nil , 2,  2, [:label, :device], 'Writes the tape on the device.')
    a << Arg.new('--verify'         , nil , 2,  2, [:label, :device], 'Verifies the tape on the device.')
    a << Arg.new('--write-verify'   , nil , 2,  2, [:label, :device], 'Writes and verifies the tape on the device.')
    a << Arg.new('--replace'        , nil , 2,  2, [:label, :label] , 'Replaces the tape in the database.')

    a << Arg.new('--add-tapeset'    , nil , 2, -1, [:name, :path]   , 'Adds a tapeset to the database.')
    a << Arg.new('--remove-tapesets', nil , 1, -1, [:name]          , 'Removes tapesets from the database.')
    a << Arg.new('--rename'         , nil , 1,  2, [:name, :name]   , 'Renames a tapeset in the database.')
    a << Arg.new('--list-tapesets'  , nil , 0, -1, [:searchterm]    , 'Lists tapesets in the database.')
    a << Arg.new('--info-tapesets'  , nil , 0, -1, [:name]          , 'Shows info about tapesets in the database.')
    return a
end

def tool_usage(report, actions, modifiers)
    map = []
    map << ['Actions:', [['Misc:', 1], ['Paths:', 5], ['Tapes:', 13], ['Tapesets:', 5]]]
    map << ['Modifiers:', [['Misc:', 4], ['Tapes:', 2], ['Tapesets:', 5]]]

    tool_show_usage(report, 'backuptool usage help:', actions, modifiers, map)
end

def tool_validate_arg(arg, type)
    case type
    when :path
        return File.exists?(arg)
    when :label
        return (arg =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (arg =~ /[A-Z0-9]{6}M8/)
    when :device
        return File.readable?(arg) && File.writable?(arg)
    when :searchterm, :name
        # There is no enforcement on search terms or names.
        return true
    else
        # Incorrect type is never valid.
        return false
    end
end

def tool_split_labels(args)
    new_args = []
    args.each() do |arg|
        new_args << arg.split('*').reject() do |c| c.empty?() end
    end
    new_args.flatten!()
    unless (new_args.nil?())
        new_args.uniq!()
    end
    return new_args
end

def tool_split_modifiers(modifiers)
    verbose = false
    quiet = false
    double = false
    triple = false
    incremental = false
    ffd = false
    async = false
    rewind = false
    offline = false
    no_tape_level = false
    sql = false

    modifiers.each() do |modifier|
        case modifier.long()
        when '--verbose'
            verbose = true
        when '--quiet'
            quiet = true
            verbose = false
        when '--double'
            double = true unless (triple)
        when '--triple'
            double = false
            triple = true
        when '--incremental'
            incremental = true
        when '--ffd'
            ffd = true
        when '--async'
            async = true
        when '--rewind'
            rewind = true
        when '--offline'
            offline = true
        when '--no-tape-level'
            no_tape_level = true
        when '--sql'
            sql = true
        end
    end

    return verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql
end

def tool_validate_command_line(report, actions, args)
    if (actions.length() == 0)
        report.error('No valid action(s) specified.')
        return false
    end
    if (actions.length() > 1)
        report.error('Too many actions specified.')
        return false
    end

    action = actions[0]
    min_args = action.min_args()
    max_args = action.max_args()

    if (args.length() < min_args)
        report.error('Not enough args.')
        return false
    end

    if ((max_args != -1) && (args.length() != max_args))
        report.error('Incorrect number of args.')
        return false
    end

    arg_index = 0
    args.length().times() do ||
        arg = args[arg_index]
        types = action.args_type()
        if (arg_index >= types.length())
            type = types.last()
        else
            type = types[arg_index]
        end

        unless (tool_validate_arg(arg, type))
            report.error('Invalid arg: ' + arg)
            return false
        end

        arg_index += 1
    end

    return true
end

#-----------------------------------------------------------------------------------------------------------------------
# Main section

begin
    report = ReportBase.new()

    # Prepare for dealing with command line.
    possible_actions = tool_build_actions()
    possible_modifiers = tool_build_modifiers()

    # Process command line and check validity.
    actions, modifiers, args = tool_parse_command_line(report, possible_actions, possible_modifiers)
    args = tool_split_labels(args) unless (args.nil?())
    exit(-1) unless (tool_validate_command_line(report, actions, args))

    verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql = \
        tool_split_modifiers(modifiers)

    report.configure(verbose, quiet)

    db = nil

    # Execute selected action.
    action = actions[0].long()
    case action
    when '--help'
        tool_usage(report, possible_actions, possible_modifiers)

    when '--add-paths'
        path_add(db, report, args)
    when '--update'
        path_update(db, report, args)
    when '--remove-paths'
        path_remove(db, report, args)
    when '--prune'
        path_prune(db, report, args)
    when '--check'
        path_check(db, report, args)

    when '--add-tapes'
        tape_add(db, report, args)
    when '--remove-tapes'
        tape_remove(db, report, args)
    when '--list-tapes'
        tape_list(db, report, args) # TODO: Warning: Changed signature.
    when '--info-tapes'
        tape_info(db, report, args) # TODO: Warning: Changed signature.
    when '--manifest'
        tape_manifest(db, report, args[0]) # TODO: Warning: Changed signature.
    when '--mark-erased'
        tape_mark_erased(db, report, args)
    when '--mark-written'
        tape_mark_written(db, report, args)
    when '--mark-verified'
        tape_mark_verified(db, report, args)
    when '--erase'
        tape_erase(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write'
        tape_write(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--verify'
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write-verify'
        tape_write(report, true, false, args[0], args[1]) # TODO: Warning: Changed signature.
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--replace'
        tape_update(db, report, args[0], args[1]) # TODO: Change name to tape_replace.

    when '--add-tapeset'
        tapeset_add(db, report, double, triple, incremental, ffd, no_tape_level, args) # Warning: Changed signature.
    when '--remove-tapesets'
        tapeset_remove(db, report, args)
    when '--rename'
        tapeset_update(db, report, args[0], args[1])
    when '--list-tapesets'
        tapeset_list(db, report, args)
    when '--info-tapesets'
        tapeset_info(db, report, args)
    else
        report.error('Bug in tool_validate_command_line, should never be able to enter here.')
    end

    report.info(args.to_s().color(CC::BLUE))
    report.info([verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql].to_s().color(CC::GREEN))

    report.table([[verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql]])
rescue SQLite3::Exception => exception
    report.db_exception(exception)
ensure
    db.close() if (db)
end
