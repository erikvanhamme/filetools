#!/usr/bin/ruby

class Arg
    attr_accessor :long, :short, :min_args, :max_args, :args_type, :help

    def initialize(long, short, min_args, max_args, args_type, help)
        @long = long
        @short = short
        @min_args = min_args
        @max_args = max_args
        @args_type = args_type
        @help = help
    end
end

def tool_build_modifiers()
    m = []
    m << Arg.new('--verbose'      , '-v', 0, 0, [], 'Run verbosely.')
    m << Arg.new('--quiet'        , '-q', 0, 0, [], 'Run quietly.')
    m << Arg.new('--sql'          , nil , 0, 0, [], 'Shows SQL queries. Useful for debugging.')
    m << Arg.new('--async'        , nil , 0, 0, [], 'Database in async mode. Unsafe if PC unstable or power cut.')

    m << Arg.new('--rewind'       , nil , 0, 0, [], 'Rewinds tape after write or verify.')
    m << Arg.new('--offline'      , nil , 0, 0, [], 'Offlines (ejects) tape after write or verify.')

    m << Arg.new('--double'       , '-2', 0, 0, [], 'Double redundancy for --add-tapeset.')
    m << Arg.new('--triple'       , '-3', 0, 0, [], 'Triple redundancy for --add-tapeset.')
    m << Arg.new('--incremental'  , '-i', 0, 0, [], 'Incremental tapeset creation for --add-tapeset.')
    m << Arg.new('--ffd'          , nil , 0, 0, [], 'First Fit Decreasing bin packing for --add-tapeset.')
    m << Arg.new('--no-tape-level', nil , 0, 0, [], 'Fill tape to max instead of leveling for --add-tapeset.')

    return m
end

def tool_build_actions()
    a = []
    a << Arg.new('--help'           , '-h', 0,  0, []               , 'Displays this help.')

    a << Arg.new('--add-paths'      , nil , 1, -1, [:path]          , 'Adds paths to database.')
    a << Arg.new('--update'         , nil , 1, -1, [:path]          , 'Updates paths in database.')
    a << Arg.new('--remove-paths'   , nil , 1, -1, [:path]          , 'Removes paths from database.')
    a << Arg.new('--prune'          , nil , 1, -1, [:path]          , 'Checks database paths for removed files.')
    a << Arg.new('--check-paths'    , nil , 1, -1, [:path]          , 'Checks database paths for duplicates.')

    a << Arg.new('--add-tapes'      , nil , 1, -1, [:label]         , 'Adds tapes to database.')
    a << Arg.new('--remove-tapes'   , nil , 1, -1, [:label]         , 'Removes tapes from database.')
    a << Arg.new('--list-tapes'     , nil , 0, -1, [:searchterm]    , 'Lists tapes in database.')
    a << Arg.new('--info-tapes'     , nil , 0, -1, [:label]         , 'Shows info about tapes in database.')
    a << Arg.new('--manifest'       , nil , 1,  1, [:label]         , 'Shows the files on a tape.')
    a << Arg.new('--mark-erased'    , nil , 1, -1, [:label]         , 'Marks tapes as erased.')
    a << Arg.new('--mark-written'   , nil , 1, -1, [:label]         , 'Marks tapes as written.')
    a << Arg.new('--mark-verified'  , nil , 1, -1, [:label]         , 'Marks tapes as verified.')
    a << Arg.new('--erase'          , nil , 2,  2, [:label, :device], 'Erases the tape on the device.')
    a << Arg.new('--write'          , nil , 2,  2, [:label, :device], 'Writes the tape on the device.')
    a << Arg.new('--verify'         , nil , 2,  2, [:label, :device], 'Verifies the tape on the device.')
    a << Arg.new('--write-verify'   , nil , 2,  2, [:label, :device], 'Writes and verifies the tape on the device.')
    a << Arg.new('--replace'        , nil , 2,  2, [:label, :label] , 'Replaces the tape in the database.')

    a << Arg.new('--add-tapeset'    , nil , 2, -1, [:name, :path]   , 'Adds a tapeset to the database.')
    a << Arg.new('--remove-tapesets', nil , 1, -1, [:name]          , 'Removes tapesets from the database.')
    a << Arg.new('--rename'         , nil , 1,  2, [:name, :name]   , 'Renames a tapeset in the database.')
    a << Arg.new('--list-tapesets'  , nil , 0, -1, [:searchterm]    , 'Lists tapesets in the database.')
    a << Arg.new('--info-tapesets'  , nil , 0, -1, [:name]          , 'Shows info about tapesets in the database.')
    return a
end

def tool_find_arg_short(args, short)
    args.each() do |arg|
        return arg if (arg.short() == short)
    end unless (args.nil?())
    return nil
end

def tool_find_arg_long(args, long)
    args.each() do |arg|
        return arg if (arg.long() == long)
    end unless (args.nil?())
    return nil
end

def tool_usage_args(action)
    args = ''
    unless (action.nil?())
        action.args_type().each() do |arg|
            args += "#{arg.upcase} "
        end
        args.chomp!(' ')
        args += '...' if (action.max_args() == -1)
        args = "<#{args}>" if ((action.min_args() == 0) && (action.max_args() != 0))
    end
    return args
end

def tool_usage(actions, modifiers)
    puts('backuptool usage help:')
    puts('======================')

    map = []
    map << ['Actions:', [['Misc:', 1], ['Paths:', 5], ['Tapes:', 13], ['Tapesets:', 5]]]
    map << ['Modifiers:', [['Misc:', 4], ['Tapes:', 2], ['Tapesets:', 5]]]

    all = []
    all << actions
    all << modifiers
    all.flatten!()

    index = 0
    map.each() do |submap|
        puts(submap[0])
        puts('-' * submap[0].length())
        submap[1].each() do |subsubmap|
            puts(subsubmap[0])
            subsubmap[1].times() do ||
                action = all[index]
                args = tool_usage_args(action)
                short = action.short().nil?() ? '' : action.short()
                long = "#{action.long()} #{args}"
                
                short = short + (' ' * (10 - short.length()))
                long = long + (' ' * (35 - long.length()))
                puts(short + long + action.help())
        
                index += 1
            end
        end
    end
end

def tool_parse_command_line(actions, modifiers)
    selected_actions = []
    selected_modifiers = []

    delete = []
    ARGV.each() do |arg|
        if (arg.match(/^\-[a-zA-Z0-9]{1}$/))
            # Deal with short action or modifier.
            action = tool_find_arg_short(actions, arg)
            modifier = tool_find_arg_short(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                puts 'ERROR ' + arg
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
        if (arg.match(/^\-\-[a-zA-Z0-9\-]{2,}$/))
            # Deal with long action or modifier.
            action = tool_find_arg_long(actions, arg)
            modifier = tool_find_arg_long(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                puts 'ERROR ' + arg
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
    end
    delete.each() do |del|
        ARGV.delete_at(ARGV.index(del))
    end
    
    return selected_actions, selected_modifiers, ARGV
end

def tool_validate_command_line(actions, modifiers, args)
    if (actions.length() == 0)
        puts 'ERROR no valid action(s) specified.'
        return false
    end
    if (actions.length() > 1)
        puts 'ERROR too many actions specified.'
        return false
    end

    action = actions[0]
    min_args = action.min_args()
    max_args = action.max_args()

    if (args.length() < min_args) 
        puts 'ERROR not enough args.'
        return false
    end

    if ((max_args != -1) && (args.length() != max_args))
        puts 'ERROR incorrect number of args.'
        return false
    end

    arg_index = 0
    args.length().times() do ||
        arg = args[arg_index]
        types = action.args_type()
        type = nil
        if (arg_index >= types.length())
            type = types.last()
        else
            type = types[arg_index]
        end

        unless (tool_validate_arg(arg, type))
            puts 'ERROR invalid arg: ' + arg
            return false
        end

        arg_index += 1
    end

    return true
end

def tool_validate_arg(arg, type)
    case type
    when :path
        return File.exists?(arg)
    when :label
        return (arg =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (arg =~ /[A-Z0-9]{6}M8/)
    when :device
        return File.readable?(arg) && File.writable?(arg)
    when :searchterm, :name
        # There is no enforcement on search terms or names.
        return true
    else
        # Incorrect type is never valid.
        return false
    end
end

def tool_split_labels(args)
    new_args = []
    args.each() do |arg|
        new_args << arg.split('*').reject() do |c| c.empty?() end
    end
    new_args.flatten!()
    unless (new_args.nil?())
        new_args.uniq!()
    end
    return new_args
end

def tool_split_modifiers(modifiers)
    verbose = false
    quiet = false
    double = false
    triple = false
    incremental = false
    ffd = false
    async = false
    rewind = false
    offline = false
    no_tape_level = false
    sql = false

    modifiers.each() do |modifier|
        case modifier.long()
        when '--verbose'
            verbose = true
        when '--quiet'
            quiet = true
            verbose = false
        when '--double'
            double = true unless (triple)
        when '--triple'
            double = false
            triple = true
        when '--incremental'
            incremental = true
        when '--ffd'
            ffd = true
        when '--async'
            async = true
        when '--rewind'
            rewind = true
        when '--offline'
            offline = true
        when '--no-tape-level'
            no_tape_level = true
        when '--sql'
            sql = true
        end
    end

    return verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql
end

def tool_main()
    # Prepare for dealing with command line.
    possible_actions = tool_build_actions()
    possible_modifiers = tool_build_modifiers()

    # Process command line and check validity.
    actions, modifiers, args = tool_parse_command_line(possible_actions, possible_modifiers)
    args = tool_split_labels(args) unless (args.nil?())
    exit(-1) unless (tool_validate_command_line(actions, modifiers, args))

    verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql = \
        tool_split_modifiers(modifiers)

    db = nil
    report = nil

    # Execute selected action.
    action = actions[0].long()
    case action
    when '--help'
        tool_usage(possible_actions, possible_modifiers)
    
    when '--add-paths'
        path_add(db, report, args)
    when '--update'
        path_update(db, report, args)
    when '--remove-paths'
        path_remove(db, report, args)
    when '--prune'
        path_prune(db, report, args)
    when '--check'
        path_check(db, report, args)
    
    when '--add-tapes'
        tape_add(db, report, args)
    when '--remove-tapes'
        tape_remove(db, report, args)
    when '--list-tapes'
        tape_list(db, report, args) # TODO: Warning: Changed signature.
    when '--info-tapes'
        tape_info(db, report, args) # TODO: Warning: Changed signature.
    when '--manifest'
        tape_manifest(db, report, args[0]) # TODO: Warning: Changed signature.
    when '--mark-erased'
        tape_mark_erased(db, report, args)
    when '--mark-written'
        tape_mark_written(db, report, args)
    when '--mark-verified'
        tape_mark_verified(db, report, args)
    when '--erase'
        tape_erase(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write'
        tape_write(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--verify'
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write-verify'
        tape_write(report, true, false, args[0], args[1]) # TODO: Warning: Changed signature.
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--replace'
        tape_update(db, report, args[0], args[1]) # TODO: Change name to tape_replace.

    when '--add-tapeset'
        tapeset_add(db, report, double, triple, incremental, ffd, no_tape_level, args) # Warning: Changed signature.
    when '--remove-tapesets'
        tapeset_remove(db, report, args)
    when '--rename'
        tapeset_update(db, report, args[0], args[1])
    when '--list-tapesets'
        tapeset_list(db, report, args)
    when '--info-tapesets'
        tapeset_info(db, report, args)
    end

    puts args.to_s()
    puts [verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql].to_s()
end

tool_main()