#!/usr/bin/ruby

# Copyright 2018 Erik Van Hamme
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'sqlite3'

#-----------------------------------------------------------------------------------------------------------------------
# Class definitions

module CC # COMMON
    BLACK = 30
    RED = 31
    GREEN = 32
    YELLOW = 33
    BLUE = 34
    MAGENTA = 35
    CYAN = 36
    WHITE = 37
    BRIGHT_BLACK = 90
    BRIGHT_RED = 91
    BRIGHT_GREEN = 92
    BRIGHT_YELLOW = 93
    BRIGHT_BLUE = 94
    BRIGHT_MAGENTA = 95
    BRIGHT_CYAN = 96
    BRIGHT_WHITE = 97
end

class String
    def color(fg, bg = nil) # COMMON
        if (bg.nil?())
            return "\e[#{fg}m#{self}\e[0m"
        else
            return "\e[#{fg};#{bg + 10}m#{self}\e[0m"
        end
    end

    def to_ws(width) # COMMON
        l = length()
        if (l < width)
            # Grow.
            return self + (' ' * (width - l))
        elsif (l > width)
            # Shrink.
            if (width > 3)
                return self[0..(width - 4)] + '...'
            else
                return self[0..(width - 1)]
            end
        else
            return self
        end
    end
end

class Array
    def keys() # COMMON
        k = []
        for i in 0..(length() - 1)
            k << i
        end
        return k
    end
end

class Arg # COMMON
    attr_accessor :long, :short, :min_args, :max_args, :args_type, :help

    def initialize(long, short, min_args, max_args, args_type, help)
        @long = long
        @short = short
        @min_args = min_args
        @max_args = max_args
        @args_type = args_type
        @help = help
    end
end

class ReportBase # COMMON
    def configure(verbose, quiet)
        @verbose = verbose
        @quiet = quiet
    end

    def msg(s)
        puts(s) if (@verbose)
    end

    def always(s)
        puts(s)
    end

    def info(s)
        puts(s.color(CC::GREEN)) unless (@quiet)
    end

    def warning(s)
        puts("Warning: #{s}".color(CC::YELLOW))
    end

    def error(s)
        puts("Error: #{s}".color(CC::RED))
    end

    def time(s, t_time)
        puts("#{s} at #{t_time}.".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def duration(s, t_start, t_end)
        d = t_end - t_start
        fraction = d % 1
        d -= fraction
        fraction = (fraction * 100).round(0)
        seconds = d % 60
        d = (d - seconds) / 60
        minutes = d % 60
        d = (d - minutes) / 60
        hours = d % 60

        d_s = sprintf('%02d:%02d:%02d.%02d', hours, minutes, seconds, fraction)

        puts("#{s} at #{t_end}. Duration was #{d_s} .".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def table(data, columns = nil, widths = nil, hide_table = false)
        # Assemble the columns from the data unless given.
        if (columns.nil?())
            columns = []
            data.each() do |row|
                columns << row.keys()
            end
            columns.flatten!().uniq!()
        end

        # Calculate the wanted column lengths from the data.
        lengths = Array.new(columns.length(), 0)
        strings = []
        col_idx = 0
        columns.each() do |col|
            l = col.to_s().length()
            if (lengths[col_idx] < l)
                lengths[col_idx] = l
            end
            col_idx += 1
        end
        data.each() do |row|
            col_idx = 0
            columns.each() do |col|
                s = row[col].to_s()
                l = s.length()

                if (lengths[col_idx] < l)
                    lengths[col_idx] = l
                end

                strings << s

                col_idx += 1
            end
        end

        # Deal with maximum widths if provided.
        unless (widths.nil?())
            col_idx = 0
            columns.each() do |col|
                unless (widths[col].nil?())
                    lengths[col_idx] = widths[col]
                end
                col_idx += 1
            end
        end

        # Print the table header.
        unless (hide_table)
            header = ''
            line = ''
            col_idx = 0
            columns.each() do |col|
                header += col.to_s().upcase().to_ws(lengths[col_idx]) + ' | '
                line += ('-' * lengths[col_idx]) + '-+-'
                col_idx += 1
            end
            header.chomp!(' | ')
            line.chomp!('-+-')
            puts header
            puts line
        end

        # Print the table data.
        separator = hide_table ? '' : ' | '
        idx = 0
        data.length().times() do ||
            row_string = ''
            col_idx = 0
            columns.length().times() do ||
                row_string += strings[idx].to_ws(lengths[col_idx]) + separator
                col_idx += 1
                idx += 1
            end
            row_string.chomp!(separator)
            puts row_string
        end
    end
end

class DbWrapper # COMMON
    def initialize()
        @db = nil
    end

    def wrap(db)
        @db = db
    end

    def execute(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.execute(sql)
    end

    def get_first_value(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_value(sql)
    end

    def get_first_row(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_row(sql)
    end

    def changes()
        return @db.changes()
    end

    def close()
        @db.close()
    end
end

class Report < ReportBase
    def initialize()
        @r = { :f_add => 0, :f_up => 0, :f_rm => 0, :t_add => 0, :t_up => 0, :t_rm => 0, :s_add => 0, :s_up => 0,
               :s_rm => 0, :l_add => 0, :l_rm => 0 }
    end

    def tool_init(version, db_version) # TODO: Delete me.
        puts("Backuptool (version: #{version}, db_version: #{db_version})".color(CC::CYAN)) unless (@quiet)
    end

    def db_create() # TODO: Delete me.
        warning('New database created.') unless (@quiet)
    end

    def db_increment(from) # TODO: Delete me.
        warning("Database schema update from #{from} to #{from + 1}.")
    end

    def db_incompatible(version_expected, version, db_version_expected, db_version) # TODO: Delete me.
        error("Incompatible versions. (db_v: #{version} > exp_db_v: #{version_expected}) || " +
                  "(schema_db_v: #{db_version} > exp_schema_db_v: #{db_version_expected})")
    end

    def db_async() # TODO: Delete me.
        warning('Database in asynchronous mode.') unless (@quiet)
    end

    def db_init(files, tapes, tapesets, links)
        data = [{files: files, tapes: tapes, tapesets: tapesets, links: links}]
        puts('Database loaded. Contents:') if (@verbose)
        table(data, data[0].keys) if (@verbose)
    end

    def db_exception(exception) # TODO: Delete me.
        error('SQL exception: ' + exception.to_s())
    end

    def file_added(absolute_path)
        @r[:f_add] += 1
        puts("File #{absolute_path} was added.".color(CC::BLUE)) if (@verbose)
    end

    def file_updated(absolute_path)
        @r[:f_up] += 1
        puts("File #{absolute_path} was updated.".color(CC::BLUE)) if (@verbose)
    end

    def file_removed(absolute_path)
        @r[:f_rm] += 1
        puts("File #{absolute_path} was removed.".color(CC::BLUE)) if (@verbose)
    end

    def file_duplicate(db_absolute_path, match_absolute_path) # TODO: Delete me.
        info("Duplicate file: master=#{db_absolute_path} duplicate=#{match_absolute_path}")
    end

    def tape_added(label)
        @r[:t_add] += 1
        puts("Tape #{label} added.".color(CC::BLUE)) if (@verbose)
    end

    def tape_updated(label)
        @r[:t_up] += 1
        puts("Tape #{label} updated.".color(CC::BLUE)) if (@verbose)
    end

    def tape_removed(label)
        @r[:t_rm] += 1
        puts("Tape #{label} removed.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_added(name)
        @r[:s_add] += 1
        puts("Tapeset #{name} added.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_updated(name)
        @r[:s_up] += 1
        puts("Tapeset #{name} updated.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_removed(name)
        @r[:s_rm] += 1
        puts("Tapeset #{name} removed.".color(CC::BLUE)) if (@verbose)
    end

    def link_added(path, label, tapeset)
        @r[:l_add] += 1
        puts("Link added: #{path} #{label} #{tapeset}".color(CC::BLUE)) if (@verbose)
    end

    def link_removed(path, label, tapeset)
        @r[:l_rm] += 1
        puts("Link removed: #{path} #{label} #{tapeset}".color(CC::BLUE)) if (@verbose)
    end

    def finalize()
        if (@verbose)
            puts('Report:')
            if ((@r.values.inject(0) do |sum, x| sum + x end) > 0)
                table([@r], @r.keys)
            else
                puts('No Database modifications.')
            end
        end
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# DB method section

def db_empty?(db)
    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')
    version_table.empty?()
end

def db_create_version_table(db, version, db_version)
    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')
    db.execute("INSERT INTO version(version, db_version) VALUES(#{version}, #{db_version})")
end

def db_create_files_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, sha1 TEXT, size INTEGER, mtime INTEGER,' +
                   ' path TEXT, on_disk INTEGER)')
    db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
    db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY, label TEXT, size INTEGER, tapeset_idx' +
                   ' INTEGER, written INTEGER, verified INTEGER)')
end

def db_create_tapesets_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY, name TEXT UNIQUE, tape_count INTEGER)')
end

def db_create_links_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS links(file_number INTEGER, tape_number INTEGER, tapeset_number INTEGER)')
end

def db_create_schema(db, report, version, db_version)
    db_create_version_table(db, version, db_version)
    db_create_files_table(db)
    db_create_tapes_table(db)
    db_create_tapesets_table(db)
    db_create_links_table(db)
    report.db_create()
end

def db_increment_schema(db, current, report)
    report.db_increment(current)
    if (current == 1)
        # Create the new links table and fill it with the information from the other tables.
        db_create_links_table(db)
        db.execute('INSERT INTO links (file_number, tape_number, tapeset_number) SELECT file_number, tape_number,' +
                       ' tapeset FROM file_tape_links LEFT JOIN tapes ON tapes.number=file_tape_links.tape_number')

        # Drop the column tapeset from tapes table through copying to new table after rename. (Sqlite3 does not support
        # drop column.)
        db.execute('ALTER TABLE tapes RENAME TO tapes_v1')
        db_create_tapes_table(db)
        db.execute('INSERT INTO tapes (number, label, size, tapeset_idx) SELECT number, label, size, tapeset_idx FROM' +
                       ' tapes_v1')

        # Drop the unused tables.
        db.execute('DROP TABLE file_tape_links')
        db.execute('DROP TABLE tapes_v1')
    end
    if (current == 2)
        # TODO: Handle schema update from V2 to V3 here.
    end
    current += 1
    db.execute("UPDATE version SET db_version=#{current}")
    return current
end

def db_update_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != version)
        db.execute("UPDATE version SET version=#{version}")
    end

    while (db_version_in_db < db_version)
        db_version_in_db = db_increment_schema(db, db_version_in_db, report)
    end
end

def db_check_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if ((version_in_db > version) || (db_version_in_db > db_version))
        report.db_incompatible(version, version_in_db, db_version, db_version_in_db)
        exit(-1) # Impossible to continue.
    end

    db_update_schema(db, report, version, db_version)
end

def db_init(report, version, db_version, async, wrapper = nil)
    if (wrapper.nil?)
        db = SQLite3::Database.new("backuptool.db")
    else
        wrapper.wrap(SQLite3::Database.new("backuptool.db"))
        db = wrapper
    end

    if (async)
        db.execute('PRAGMA synchronous = OFF')
        report.db_async()
    end

    if (db_empty?(db))
        db_create_schema(db, report, version, db_version)
    else
        db_check_schema(db, report, version, db_version)
    end

    files = db.get_first_value('SELECT COUNT(*) FROM files')
    tapes = db.get_first_value('SELECT COUNT(*) FROM tapes')
    tapesets = db.get_first_value('SELECT COUNT(*) FROM tapesets')
    links = db.get_first_value('SELECT COUNT(*) FROM links')
    report.db_init(files, tapes, tapesets, links)

    return db
end

#-----------------------------------------------------------------------------------------------------------------------
# Tape method section

def tape_valid_label?(label)
    if (label.length() != 8)
        return false
    end

    # Taken LTO tape label spec from:
    # https://www.ibm.com/support/knowledgecenter/en/STCMML8/com.ibm.storage.ts3500.doc/ipg_3584_mehlab.html
    # Only supporting LTO1-LTO8(+M8) for now.
    return (label =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (label =~ /[A-Z0-9]{6}M8/)
end

def tape_size(label)
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L1'
        size = 100000000000
    when 'L2'
        size = 200000000000
    when 'L3'
        size = 400000000000
    when 'L4'
        size = 800000000000
    when 'L5'
        size = 1500000000000
    when 'L6'
        size = 2500000000000
    when 'L7'
        size = 6000000000000
    when 'L8'
        size = 12000000000000
    when 'M8'
        size = 9000000000000
    end
    return size
end

def tape_add(db, report, tapes)
    tapes.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset_idx) VALUES (\"#{label}\", #{size}, -1)")
            report.tape_added(label)
        else
            report.error("Tape with label #{label} is already in the database.")
        end
    end
end

def tape_update(db, report, old_name, new_name)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{new_name}\"")
    if (in_db == 0)
        db.execute("UPDATE tapes SET label=\"#{new_name}\", written=NULL, verified=NULL WHERE label=\"#{old_name}\"")
        report.tape_updated(old_name)
    else
        report.error("Cannot rename #{old_name} to #{new_name}, #{new_name} exists in the database.")
    end
end

def tape_remove(db, report, tapes)
    tapes.each() do |label|
        count = db.get_first_value("SELECT COUNT (*) FROM links LEFT JOIN tapes ON tapes.number=links.tape_number" +
                                       " WHERE tapes.label=\"#{label}\"")
        if (count == 0)
            db.execute("DELETE FROM tapes WHERE label=\"#{label}\"")
            report.tape_removed(label)
        else
            report.error("Tape with label #{label} is part of a tapeset.")
        end
    end
end

def tape_list(db, report, tapes_fuzzy)
    query = 'SELECT label FROM tapes'
    unless (tapes_fuzzy.empty?())
        query += ' WHERE'
        tapes_fuzzy.each() do |label|
            query += " label LIKE \"#{label}%\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'
    tapes = db.execute(query)
    tapes.collect!() do |tape|
        {:label => tape[0]}
    end
    report.table(tapes, [:label])
end

def tape_sizes(db, tape_number)
    query = "SELECT files.size FROM links LEFT JOIN files ON links.file_number = files.number WHERE " +
        "links.tape_number=#{tape_number}"
    files = db.execute(query)

    return tar_calc_sizes(files, 0)
end

def tape_info(db, report, tapes, verbose)
    query = 'SELECT DISTINCT tapes.number, tapes.label, tapes.size, tapes.tapeset_idx, tapesets.name, tapes.written,' +
        ' tapes.verified FROM tapes LEFT JOIN links ON links.tape_number=tapes.number LEFT JOIN tapesets ON' +
        ' tapesets.number=links.tapeset_number'
    unless (tapes.empty?())
        query += ' WHERE'
        tapes.each() do |label|
            query += " label=\"#{label}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY tapes.label ASC'

    tapes = db.execute(query)
    tapes.collect!() do |tape|
        files, size, tar_size, overhead = tape_sizes(db, tape[0])

        used = (tar_size.to_f() / (tape[2].to_f() * 0.99)) * 100

        w = tape[5].nil? ? nil : Time.at(tape[5])
        v = tape[6].nil? ? nil : Time.at(tape[6])

        {:label => tape[1], :files => files, :size => size, :tar_size => tar_size, :overhead => overhead,
         :capacity => tape[2], :usage => "#{used.round(1)} %", :ts_idx => tape[3], :tapeset => tape[4],
         :written => w, :verified => v}
    end
    if (verbose)
        report.table(tapes, [:label, :files, :size, :tar_size, :overhead, :capacity, :usage, :ts_idx, :tapeset,
                             :written, :verified])
    else
        report.table(tapes, [:label, :files, :usage, :tapeset, :written, :verified])
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Tar method section

def tar_calc_sizes(files, column)
    size = 0
    overhead = 0
    files.each() do |file|
        size += file[column]
        overhead += (512 * 3) + (512 - (file[column] % 512))
    end
    tar_size_no_footer = size + overhead
    modulo = tar_size_no_footer % (8192 * 512)
    if (modulo < 1024)
        tar_footer_size = (8192 * 512) + modulo
    else
        tar_footer_size = (8192 * 512) - modulo
    end
    tar_size = tar_size_no_footer + tar_footer_size
    overhead += tar_footer_size

    if (files.length() == 0)
        tar_size = 0
        overhead = 0
    end

    return files.length(), size, tar_size, overhead
end

#-----------------------------------------------------------------------------------------------------------------------
# Tool method section

def tool_find_arg_short(args, short) # COMMON
    args.each() do |arg|
        return arg if (arg.short() == short)
    end unless (args.nil?())
    return nil
end

def tool_find_arg_long(args, long) # COMMON
    args.each() do |arg|
        return arg if (arg.long() == long)
    end unless (args.nil?())
    return nil
end

def tool_usage_args(action) # COMMON
    args = ''
    unless (action.nil?())
        action.args_type().each() do |arg|
            args += "#{arg.upcase} "
        end
        args.chomp!(' ')
        args += '...' if (action.max_args() == -1)
        args = "<#{args}>" if ((action.min_args() == 0) && (action.max_args() != 0))
    end
    return args
end

def tool_show_usage(report, banner, actions, modifiers, map) # COMMON
    report.always(banner)
    report.always('=' * banner.length)

    all = []
    all << actions
    all << modifiers
    all.flatten!()

    index = 0
    map.each() do |submap|
        report.always(submap[0])
        report.always('-' * submap[0].length())
        submap[1].each() do |subsubmap|
            report.always(subsubmap[0])
            subsubmap[1].times() do ||
                action = all[index]
                args = tool_usage_args(action)
                short = action.short().nil?() ? '' : action.short()
                long = "#{action.long()} #{args}"

                short = short + (' ' * (10 - short.length()))
                long = long + (' ' * (35 - long.length()))
                report.always(short + long + action.help())

                index += 1
            end
        end
    end
end

def tool_parse_command_line(report, actions, modifiers) # COMMON
    selected_actions = []
    selected_modifiers = []

    delete = []
    ARGV.each() do |arg|
        if (arg.match(/^\-[a-zA-Z0-9]{1}$/))
            # Deal with short action or modifier.
            action = tool_find_arg_short(actions, arg)
            modifier = tool_find_arg_short(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
        if (arg.match(/^\-\-[a-zA-Z0-9\-]{2,}$/))
            # Deal with long action or modifier.
            action = tool_find_arg_long(actions, arg)
            modifier = tool_find_arg_long(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
    end
    delete.each() do |del|
        ARGV.delete_at(ARGV.index(del))
    end

    return selected_actions, selected_modifiers, ARGV
end

def tool_build_modifiers()
    m = []
    m << Arg.new('--verbose'      , '-v', 0, 0, [], 'Run verbosely.')
    m << Arg.new('--quiet'        , '-q', 0, 0, [], 'Run quietly.')
    m << Arg.new('--sql'          , nil , 0, 0, [], 'Shows SQL queries. Useful for debugging.')
    m << Arg.new('--async'        , nil , 0, 0, [], 'Database in async mode. Unsafe if PC unstable or power cut.')

    m << Arg.new('--rewind'       , nil , 0, 0, [], 'Rewinds tape after write or verify.')
    m << Arg.new('--offline'      , nil , 0, 0, [], 'Offlines (ejects) tape after write or verify.')

    m << Arg.new('--double'       , '-2', 0, 0, [], 'Double redundancy for --add-tapeset.')
    m << Arg.new('--triple'       , '-3', 0, 0, [], 'Triple redundancy for --add-tapeset.')
    m << Arg.new('--incremental'  , '-i', 0, 0, [], 'Incremental tapeset creation for --add-tapeset.')
    m << Arg.new('--ffd'          , nil , 0, 0, [], 'First Fit Decreasing bin packing for --add-tapeset.')
    m << Arg.new('--no-tape-level', nil , 0, 0, [], 'Fill tape to max instead of leveling for --add-tapeset.')
    return m
end

def tool_build_actions()
    a = []
    a << Arg.new('--help'           , '-h', 0,  0, []               , 'Displays this help.')

    a << Arg.new('--add-paths'      , nil , 1, -1, [:path]          , 'Adds paths to database.')
    a << Arg.new('--update'         , nil , 1, -1, [:path]          , 'Updates paths in database.')
    a << Arg.new('--remove-paths'   , nil , 1, -1, [:path]          , 'Removes paths from database.')
    a << Arg.new('--prune'          , nil , 1, -1, [:path]          , 'Checks database paths for removed files.')
    a << Arg.new('--check-paths'    , nil , 1, -1, [:path]          , 'Checks database paths for duplicates.')

    a << Arg.new('--add-tapes'      , nil , 1, -1, [:label]         , 'Adds tapes to database.')
    a << Arg.new('--remove-tapes'   , nil , 1, -1, [:label]         , 'Removes tapes from database.')
    a << Arg.new('--list-tapes'     , nil , 0, -1, [:searchterm]    , 'Lists tapes in database.')
    a << Arg.new('--info-tapes'     , nil , 0, -1, [:label]         , 'Shows info about tapes in database.')
    a << Arg.new('--manifest'       , nil , 1,  1, [:label]         , 'Shows the files on a tape.')
    a << Arg.new('--mark-erased'    , nil , 1, -1, [:label]         , 'Marks tapes as erased.')
    a << Arg.new('--mark-written'   , nil , 1, -1, [:label]         , 'Marks tapes as written.')
    a << Arg.new('--mark-verified'  , nil , 1, -1, [:label]         , 'Marks tapes as verified.')
    a << Arg.new('--erase'          , nil , 2,  2, [:label, :device], 'Erases the tape on the device.')
    a << Arg.new('--write'          , nil , 2,  2, [:label, :device], 'Writes the tape on the device.')
    a << Arg.new('--verify'         , nil , 2,  2, [:label, :device], 'Verifies the tape on the device.')
    a << Arg.new('--write-verify'   , nil , 2,  2, [:label, :device], 'Writes and verifies the tape on the device.')
    a << Arg.new('--replace'        , nil , 2,  2, [:label, :label] , 'Replaces the tape in the database.')

    a << Arg.new('--add-tapeset'    , nil , 2, -1, [:name, :path]   , 'Adds a tapeset to the database.')
    a << Arg.new('--remove-tapesets', nil , 1, -1, [:name]          , 'Removes tapesets from the database.')
    a << Arg.new('--rename'         , nil , 1,  2, [:name, :name]   , 'Renames a tapeset in the database.')
    a << Arg.new('--list-tapesets'  , nil , 0, -1, [:searchterm]    , 'Lists tapesets in the database.')
    a << Arg.new('--info-tapesets'  , nil , 0, -1, [:name]          , 'Shows info about tapesets in the database.')
    return a
end

def tool_usage(report, actions, modifiers)
    map = []
    map << ['Actions:', [['Misc:', 1], ['Paths:', 5], ['Tapes:', 13], ['Tapesets:', 5]]]
    map << ['Modifiers:', [['Misc:', 4], ['Tapes:', 2], ['Tapesets:', 5]]]

    tool_show_usage(report, 'backuptool usage help:', actions, modifiers, map)
end

def tool_validate_arg(arg, type)
    case type
    when :path
        return File.exists?(arg)
    when :label
        return (arg =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (arg =~ /[A-Z0-9]{6}M8/)
    when :device
        return File.readable?(arg) && File.writable?(arg)
    when :searchterm, :name
        # There is no enforcement on search terms or names.
        return true
    else
        # Incorrect type is never valid.
        return false
    end
end

def tool_split_labels(args)
    new_args = []
    args.each() do |arg|
        new_args << arg.split('*').reject() do |c| c.empty?() end
    end
    new_args.flatten!()
    unless (new_args.nil?())
        new_args.uniq!()
    end
    return new_args
end

def tool_split_modifiers(modifiers)
    verbose = false
    quiet = false
    double = false
    triple = false
    incremental = false
    ffd = false
    async = false
    rewind = false
    offline = false
    no_tape_level = false
    sql = false

    modifiers.each() do |modifier|
        case modifier.long()
        when '--verbose'
            verbose = true
        when '--quiet'
            quiet = true
            verbose = false
        when '--double'
            double = true unless (triple)
        when '--triple'
            double = false
            triple = true
        when '--incremental'
            incremental = true
        when '--ffd'
            ffd = true
        when '--async'
            async = true
        when '--rewind'
            rewind = true
        when '--offline'
            offline = true
        when '--no-tape-level'
            no_tape_level = true
        when '--sql'
            sql = true
        end
    end

    return verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql
end

def tool_validate_command_line(report, actions, args)
    if (actions.length() == 0)
        report.error('No valid action(s) specified.')
        return false
    end
    if (actions.length() > 1)
        report.error('Too many actions specified.')
        return false
    end

    action = actions[0]
    min_args = action.min_args()
    max_args = action.max_args()

    if (args.length() < min_args)
        report.error('Not enough args.')
        return false
    end

    if ((max_args != -1) && (args.length() != max_args))
        report.error('Incorrect number of args.')
        return false
    end

    arg_index = 0
    args.length().times() do ||
        arg = args[arg_index]
        types = action.args_type()
        if (arg_index >= types.length())
            type = types.last()
        else
            type = types[arg_index]
        end

        unless (tool_validate_arg(arg, type))
            report.error('Invalid arg: ' + arg)
            return false
        end

        arg_index += 1
    end

    return true
end

#-----------------------------------------------------------------------------------------------------------------------
# Main section

begin
    # Initialize variables
    version = 2
    db_version = 2
    report = Report.new()
    db = nil

    # Prepare for dealing with command line.
    possible_actions = tool_build_actions()
    possible_modifiers = tool_build_modifiers()

    # Process command line and check validity.
    actions, modifiers, args = tool_parse_command_line(report, possible_actions, possible_modifiers)
    args = tool_split_labels(args) unless (args.nil?())
    exit(-1) unless (tool_validate_command_line(report, actions, args))

    verbose, quiet, double, triple, incremental, ffd, async, rewind, offline, no_tape_level, sql = \
        tool_split_modifiers(modifiers)

    report.configure(verbose, quiet)

    # Startup banner.
    report.tool_init(version, db_version)

    # Initialize the database.
    if (sql)
        db = db_init(report, version, db_version, async, DbWrapper.new())
    else
        db = db_init(report, version, db_version, async)
    end

    # Execute selected action.
    action = actions[0].long()
    case action
    when '--help'
        tool_usage(report, possible_actions, possible_modifiers)

    when '--add-paths'
        path_add(db, report, args)
    when '--update'
        path_update(db, report, args)
    when '--remove-paths'
        path_remove(db, report, args)
    when '--prune'
        path_prune(db, report, args)
    when '--check'
        path_check(db, report, args)

    when '--add-tapes'
        tape_add(db, report, args)
    when '--remove-tapes'
        tape_remove(db, report, args)
    when '--list-tapes'
        tape_list(db, report, args)
    when '--info-tapes'
        tape_info(db, report, args, verbose)
    when '--manifest'
        tape_manifest(db, report, args[0]) # TODO: Warning: Changed signature.
    when '--mark-erased'
        tape_mark_erased(db, report, args)
    when '--mark-written'
        tape_mark_written(db, report, args)
    when '--mark-verified'
        tape_mark_verified(db, report, args)
    when '--erase'
        tape_erase(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write'
        tape_write(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--verify'
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--write-verify'
        tape_write(report, true, false, args[0], args[1]) # TODO: Warning: Changed signature.
        tape_verify(report, rewind, offline, args[0], args[1]) # TODO: Warning: Changed signature.
    when '--replace'
        tape_update(db, report, args[0], args[1]) # TODO: Change name to tape_replace.

    when '--add-tapeset'
        tapeset_add(db, report, double, triple, incremental, ffd, no_tape_level, args) # Warning: Changed signature.
    when '--remove-tapesets'
        tapeset_remove(db, report, args)
    when '--rename'
        tapeset_update(db, report, args[0], args[1])
    when '--list-tapesets'
        tapeset_list(db, report, args)
    when '--info-tapesets'
        tapeset_info(db, report, args)
    else
        report.error('Bug in tool_validate_command_line, should never be able to enter here.')
    end

    # Final report.
    report.finalize()
rescue SQLite3::Exception => exception
    report.db_exception(exception)
ensure
    db.close() if (db)
end
