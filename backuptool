#!/usr/bin/ruby

# Copyright 2018 Erik Van Hamme
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'digest/sha1'
require 'find'
require 'sqlite3'

#-----------------------------------------------------------------------------------------------------------------------
# Class definitions

module CC # COMMON
    BLACK = 30
    RED = 31
    GREEN = 32
    YELLOW = 33
    BLUE = 34
    MAGENTA = 35
    CYAN = 36
    WHITE = 37
    BRIGHT_BLACK = 90
    BRIGHT_RED = 91
    BRIGHT_GREEN = 92
    BRIGHT_YELLOW = 93
    BRIGHT_BLUE = 94
    BRIGHT_MAGENTA = 95
    BRIGHT_CYAN = 96
    BRIGHT_WHITE = 97
end

class String
    def color(fg, bg = nil) # COMMON
        if (bg.nil?())
            return "\e[#{fg}m#{self}\e[0m"
        else
            return "\e[#{fg};#{bg + 10}m#{self}\e[0m"
        end
    end

    def to_ws(width) # COMMON
        l = length()
        if (l < width)
            # Grow.
            return self + (' ' * (width - l))
        elsif (l > width)
            # Shrink.
            if (width > 3)
                return self[0..(width - 4)] + '...'
            else
                return self[0..(width - 1)]
            end
        else
            return self
        end
    end
end

class Array
    def keys() # COMMON
        k = []
        for i in 0..(length() - 1)
            k << i
        end
        return k
    end
end

class Arg # COMMON
    attr_accessor :long, :short, :min_args, :max_args, :args_type, :help

    def initialize(long, short, min_args, max_args, args_type, help)
        @long = long
        @short = short
        @min_args = min_args
        @max_args = max_args
        @args_type = args_type
        @help = help
    end
end

class ReportBase # COMMON
    def configure(verbose, quiet)
        @verbose = verbose
        @quiet = quiet
    end

    def msg(s)
        puts(s) if (@verbose)
    end

    def always(s)
        puts(s)
    end

    def info(s)
        puts(s.color(CC::GREEN)) unless (@quiet)
    end

    def warning(s)
        puts("Warning: #{s}".color(CC::YELLOW))
    end

    def error(s)
        puts("Error: #{s}".color(CC::RED))
    end

    def time(s, t_time)
        puts("#{s} at #{t_time}.".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def duration(s, t_start, t_end)
        d = t_end - t_start
        fraction = d % 1
        d -= fraction
        fraction = (fraction * 100).round(0)
        seconds = d % 60
        d = (d - seconds) / 60
        minutes = d % 60
        d = (d - minutes) / 60
        hours = d % 60

        d_s = sprintf('%02d:%02d:%02d.%02d', hours, minutes, seconds, fraction)

        puts("#{s} at #{t_end}. Duration was #{d_s}.".color(CC::BRIGHT_MAGENTA)) unless (@quiet)
    end

    def table(data, columns = nil, widths = nil, hide_table = false)
        # Assemble the columns from the data unless given.
        if (columns.nil?())
            columns = []
            data.each() do |row|
                columns << row.keys()
            end
            columns.flatten!().uniq!()
        end

        # Calculate the wanted column lengths from the data.
        lengths = Array.new(columns.length(), 0)
        strings = []
        col_idx = 0
        columns.each() do |col|
            l = col.to_s().length()
            if (lengths[col_idx] < l)
                lengths[col_idx] = l
            end
            col_idx += 1
        end
        data.each() do |row|
            col_idx = 0
            columns.each() do |col|
                s = row[col].to_s()
                l = s.length()

                if (lengths[col_idx] < l)
                    lengths[col_idx] = l
                end

                strings << s

                col_idx += 1
            end
        end

        # Deal with maximum widths if provided.
        unless (widths.nil?())
            col_idx = 0
            columns.each() do |col|
                unless (widths[col].nil?())
                    lengths[col_idx] = widths[col]
                end
                col_idx += 1
            end
        end

        # Print the table header.
        unless (hide_table)
            header = ''
            line = ''
            col_idx = 0
            columns.each() do |col|
                header += col.to_s().upcase().to_ws(lengths[col_idx]) + ' | '
                line += ('-' * lengths[col_idx]) + '-+-'
                col_idx += 1
            end
            header.chomp!(' | ')
            line.chomp!('-+-')
            puts header
            puts line
        end

        # Print the table data.
        separator = hide_table ? '' : ' | '
        idx = 0
        data.length().times() do ||
            row_string = ''
            col_idx = 0
            columns.length().times() do ||
                row_string += strings[idx].to_ws(lengths[col_idx]) + separator
                col_idx += 1
                idx += 1
            end
            row_string.chomp!(separator)
            puts row_string
        end
    end
end

class DbWrapper # COMMON
    def initialize()
        @db = nil
    end

    def wrap(db)
        @db = db
    end

    def execute(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.execute(sql)
    end

    def get_first_value(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_value(sql)
    end

    def get_first_row(sql)
        puts("-> #{sql}".color(CC::MAGENTA))
        return @db.get_first_row(sql)
    end

    def changes()
        return @db.changes()
    end

    def close()
        @db.close()
    end
end

class Report < ReportBase
    def initialize()
        @r = { :f_add => 0, :f_up => 0, :f_rm => 0, :t_add => 0, :t_up => 0, :t_rm => 0, :s_add => 0, :s_up => 0,
               :s_rm => 0, :l_add => 0, :l_rm => 0 }
    end

    def file_added(absolute_path)
        @r[:f_add] += 1
        puts("File #{absolute_path} was added.".color(CC::BLUE)) if (@verbose)
    end

    def file_updated(absolute_path)
        @r[:f_up] += 1
        puts("File #{absolute_path} was updated.".color(CC::BLUE)) if (@verbose)
    end

    def file_removed(absolute_path)
        @r[:f_rm] += 1
        puts("File #{absolute_path} was removed.".color(CC::BLUE)) if (@verbose)
    end

    def tape_added(label)
        @r[:t_add] += 1
        puts("Tape #{label} added.".color(CC::BLUE)) if (@verbose)
    end

    def tape_updated(label)
        @r[:t_up] += 1
        puts("Tape #{label} updated.".color(CC::BLUE)) if (@verbose)
    end

    def tape_removed(label)
        @r[:t_rm] += 1
        puts("Tape #{label} removed.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_added(name)
        @r[:s_add] += 1
        puts("Tapeset #{name} added.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_updated(name)
        @r[:s_up] += 1
        puts("Tapeset #{name} updated.".color(CC::BLUE)) if (@verbose)
    end

    def tapeset_removed(name)
        @r[:s_rm] += 1
        puts("Tapeset #{name} removed.".color(CC::BLUE)) if (@verbose)
    end

    def link_added(path, label, tapeset)
        @r[:l_add] += 1
        puts("Link added: #{path} #{label} #{tapeset}".color(CC::BLUE)) if (@verbose)
    end

    def link_removed(path, label, tapeset)
        @r[:l_rm] += 1
        puts("Link removed: #{path} #{label} #{tapeset}".color(CC::BLUE)) if (@verbose)
    end

    def finalize()
        if (@verbose)
            puts('Report:')
            if ((@r.values.inject(0) do |sum, x| sum + x end) > 0)
                table([@r], @r.keys)
            else
                puts('No Database modifications.')
            end
        end
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# DB method section

def db_empty?(db)
    version_table = db.execute('SELECT name FROM sqlite_master WHERE type="table" AND name="version"')
    version_table.empty?()
end

def db_create_version_table(db, version, db_version)
    db.execute('CREATE TABLE version(version INTEGER NOT NULL, db_version INTEGER NOT NULL)')
    db.execute("INSERT INTO version(version, db_version) VALUES(#{version}, #{db_version})")
end

def db_create_files_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS files(number INTEGER PRIMARY KEY, sha1 TEXT, size INTEGER, mtime INTEGER,' +
                   ' path TEXT, on_disk INTEGER)')
    db.execute('CREATE INDEX IF NOT EXISTS files_sha1 ON files(sha1)')
    db.execute('CREATE INDEX IF NOT EXISTS files_path ON files(path)')
end

def db_create_tapes_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapes(number INTEGER PRIMARY KEY, label TEXT, size INTEGER, tapeset_idx' +
                   ' INTEGER, written INTEGER, verified INTEGER, ts_files INTEGER, ts_size INTEGER, tape_files' +
                   ' INTEGER, tape_size INTEGER, tar_size INTEGER)')
end

def db_create_tapesets_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapesets(number INTEGER PRIMARY KEY, name TEXT UNIQUE, tape_count INTEGER,' +
                   ' created INTEGER)')
end

def db_create_tapeset_paths_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS tapeset_paths(tapeset_number INTEGER NOT_NULL, path TEXT NOT NULL)')
end

def db_create_links_table(db)
    db.execute('CREATE TABLE IF NOT EXISTS links(file_number INTEGER, tape_number INTEGER, tapeset_number INTEGER)')
end

def db_create_schema(db, report, version, db_version)
    db_create_version_table(db, version, db_version)
    db_create_files_table(db)
    db_create_tapes_table(db)
    db_create_tapesets_table(db)
    db_create_tapeset_paths_table(db)
    db_create_links_table(db)
    report.warning('New database created.')
end

def db_increment_schema(db, current, report)
    report.warning("Database schema update from #{current} to #{current + 1}.")
    if (current == 1)
        # Create the new links table and fill it with the information from the other tables.
        db_create_links_table(db)
        db.execute('INSERT INTO links (file_number, tape_number, tapeset_number) SELECT file_number, tape_number,' +
                       ' tapeset FROM file_tape_links LEFT JOIN tapes ON tapes.number=file_tape_links.tape_number')

        # Drop the column tapeset from tapes table through copying to new table after rename. (Sqlite3 does not support
        # drop column.)
        db.execute('ALTER TABLE tapes RENAME TO tapes_v1')
        db_create_tapes_table(db)
        db.execute('INSERT INTO tapes (number, label, size, tapeset_idx) SELECT number, label, size, tapeset_idx FROM' +
                       ' tapes_v1')

        # Drop the unused tables.
        db.execute('DROP TABLE file_tape_links')
        db.execute('DROP TABLE tapes_v1')
    end
    if (current == 2)
        db.execute('ALTER TABLE tapes ADD COLUMN ts_files INTEGER')
        db.execute('ALTER TABLE tapes ADD COLUMN ts_size INTEGER')
        db.execute('ALTER TABLE tapes ADD COLUMN tape_files INTEGER')
        db.execute('ALTER TABLE tapes ADD COLUMN tape_size INTEGER')
        db.execute('ALTER TABLE tapes ADD COLUMN tar_size INTEGER')

        db.execute('ALTER TABLE tapesets ADD COLUMN created INTEGER')
    end
    if (current == 3)
        db_create_tapeset_paths_table(db)
    end
    current += 1
    db.execute("UPDATE version SET db_version=#{current}")
    return current
end

def db_update_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if (version_in_db != version)
        db.execute("UPDATE version SET version=#{version}")
    end

    while (db_version_in_db < db_version)
        db_version_in_db = db_increment_schema(db, db_version_in_db, report)
    end
end

def db_check_schema(db, report, version, db_version)
    versions = db.execute('SELECT * FROM version')
    version_in_db = versions[0][0]
    db_version_in_db = versions[0][1]

    if ((version_in_db > version) || (db_version_in_db > db_version))
        report.error("Incompatible versions. (db_v: #{version_in_db} > exp_db_v: #{version}) || " +
                  "(schema_db_v: #{db_version_in_db} > exp_schema_db_v: #{db_version})")
        exit(-1) # Impossible to continue.
    end

    db_update_schema(db, report, version, db_version)
end

def db_init(report, version, db_version, async, verbose, wrapper = nil)
    home_dir = File.expand_path('~')
    db_dir = "#{home_dir}/.local/share/backuptool"
    db_file = "#{db_dir}/backuptool.db"

    unless (File.directory?(db_dir))
        Dir.mkdir(db_dir)
    end

    if (wrapper.nil?)
        db = SQLite3::Database.new(db_file)
    else
        wrapper.wrap(SQLite3::Database.new(db_file))
        db = wrapper
    end

    if (async)
        db.execute('PRAGMA synchronous = OFF')
        report.warning('Database in asynchronous mode.')
    end

    if (db_empty?(db))
        db_create_schema(db, report, version, db_version)
    else
        db_check_schema(db, report, version, db_version)
    end

    files = db.get_first_value('SELECT COUNT(*) FROM files')
    tapes = db.get_first_value('SELECT COUNT(*) FROM tapes')
    tapesets = db.get_first_value('SELECT COUNT(*) FROM tapesets')
    links = db.get_first_value('SELECT COUNT(*) FROM links')

    data = [{files: files, tapes: tapes, tapesets: tapesets, links: links}]
    report.table(data, data[0].keys) if (verbose)
    report.msg('Database loaded.')

    return db
end

#-----------------------------------------------------------------------------------------------------------------------
# File method section

def file_sha1(absolute_path) # HELPER
    sha1 = Digest::SHA1.new()
    File.open(absolute_path, 'rb') do |iostream|
        while (block = iostream.read(4096)) && (block.length() > 0)
            sha1.update(block)
        end
    end
    return sha1.hexdigest()
end

def file_add(db, report, files) # HELPER
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            in_db = db.get_first_value("SELECT COUNT(*) FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            if (in_db == 0)
                filesize = File.size(absolute_path)
                mtime = File.mtime(absolute_path)
                sha1 = file_sha1(absolute_path)
                db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\", #{filesize}," +
                    "#{mtime.to_i}, \"#{absolute_path}\", 1)")
                report.file_added(absolute_path)
            end
        end
    end
end

def file_update(db, report, files) # HELPER
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            filesize = File.size(absolute_path)
            mtime = File.mtime(absolute_path)
            file_in_db = db.get_first_row("SELECT * FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            if ((file_in_db.nil?() == false) && ((file_in_db[2] != filesize) || (file_in_db[3] != mtime.to_i())))
                sha1 = file_sha1(absolute_path)
                file_on_tapes = db.get_first_value("SELECT COUNT(*) FROM links WHERE file_number=#{file_in_db[0]}")
                if (file_on_tapes > 0)
                    # Older version on tape, cannot update existing record.
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                    db.execute("INSERT INTO files (sha1, size, mtime, path, on_disk) VALUES (\"#{sha1}\"," +
                        " #{filesize}, #{mtime.to_i}, \"#{absolute_path}\", 1)")
                    report.file_added(absolute_path)
                else
                    # No versions on tape, can update existing record.
                    db.execute("UPDATE files SET sha1=\"#{sha1}\", size=#{filesize}, mtime=#{mtime.to_i()} WHERE" +
                        " number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                end
            end
        end
    end
end

def file_remove(db, report, files) # HELPER
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            file_in_db = db.get_first_row("SELECT number FROM files WHERE path=\"#{absolute_path}\" AND on_disk=1")
            unless (file_in_db.nil?)
                file_on_tapes = db.get_first_value("SELECT COUNT(*) FROM links WHERE file_number=#{file_in_db[0]}")
                if (file_on_tapes > 0)
                    # File is on tape, cannot remove record, update it as no longer on disk.
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file_in_db[0]}")
                    report.file_updated(absolute_path)
                else
                    # File is not on tape, can be removed.
                    db.execute("DELETE FROM files WHERE number=#{file_in_db[0]}")
                    report.file_removed(absolute_path)
                end
            end
        end
    end
end

def file_check(db, report, files) # HELPER
    files.each() do |file|
        if (File.file?(file))
            absolute_path = File.expand_path(file)
            sha1 = file_sha1(absolute_path)
            matching_sha1 = db.execute("SELECT path FROM files WHERE sha1=\"#{sha1}\" AND on_disk=1 AND NOT" +
                " path=\"#{absolute_path}\"")
            matching_sha1.each() do |match|
                report.info("File #{absolute_path} is a duplicate of #{match[0]}.")
            end
        end
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Path method section

def path_add(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_add(db, report, files)
end

def path_update(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_update(db, report, files)
end

def path_remove(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_remove(db, report, files)
end

def path_prune(db, report, paths)
    paths.each() do |path|
        absolute_path = File.expand_path(path)
        files = db.execute("SELECT number, path FROM files WHERE path LIKE \"#{absolute_path}%\" AND on_disk=1")
        files.each() do |file|
            unless (File.file?(file[1]))
                on_tape = db.get_first_value("SELECT COUNT (*) FROM links WHERE file_number=#{file[0]}")
                if (on_tape > 0)
                    db.execute("UPDATE files SET on_disk=0 WHERE number=#{file[0]}")
                    report.file_updated(file[1])
                else
                    db.execute("DELETE FROM files WHERE number=#{file[0]}")
                    report.file_removed(file[1])
                end
            end
        end
    end
end

def path_check(db, report, paths)
    files = []
    paths.each() do |dir|
        Find.find(dir) do |path|
            if (File.file?(path))
                files << path
            end
        end
    end
    file_check(db, report, files)
end

#-----------------------------------------------------------------------------------------------------------------------
# Tape method section

def tape_size(label) # HELPER
    size = 0
    suffix = label.split(//).last(2).join()
    case suffix
    when 'L1'
        size = 100000000000
    when 'L2'
        size = 200000000000
    when 'L3'
        size = 400000000000
    when 'L4'
        size = 800000000000
    when 'L5'
        size = 1500000000000
    when 'L6'
        size = 2500000000000
    when 'L7'
        size = 6000000000000
    when 'L8'
        size = 12000000000000
    when 'M8'
        size = 9000000000000
    end
    return size
end

def tape_set_compression(report, device, compression, simulate) # HELPER
    if (compression)
        report.msg('Enabling compression.')
        unless (simulate)
            result = `mt-st -f #{device} compression 1 2>&1`
        end
    else
        report.msg('Disabling compression.')
        unless (simulate)
            result = `mt-st -f #{device} compression 0 2>&1`
        end
    end
    unless (simulate)
        unless ($?.success?())
            report.error("mt-st error: #{result}")
            return false
        end
    end
    return true
end

def tape_set_block_size(report, device, block_size, simulate) # HELPER
    report.msg('Setting block size.')
    unless (simulate)
        result = `mt-st -f #{device} setblk #{block_size} 2>&1`
        unless ($?.success?())
            report.error("mt-st error: #{result}")
            return false
        end
    end
    return true
end

def tape_rewind(report, device, simulate) # HELPER
    report.msg('Rewinding tape.')
    unless (simulate)
        result = `mt-st -f #{device} rewind 2>&1`
        unless ($?.success?())
            report.error("Mt-st error: #{result}")
            return false
        end
    end
    return true
end

def tape_offline(report, device, simulate) # HELPER
    report.msg('Offlining tape.')
    unless (simulate)
        result = `mt-st -f #{device} offline 2>&1`
        unless ($?.success?())
            report.error("Mt-st error: #{result}")
            return false
        end
    end
    return true
end

def tape_add(db, report, labels)
    labels.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            size = tape_size(label)
            db.execute("INSERT INTO tapes (label, size, tapeset_idx) VALUES (\"#{label}\", #{size}, -1)")
            report.tape_added(label)
        else
            report.error("Tape with label #{label} is already in the database.")
        end
    end
end

def tape_remove(db, report, labels)
    labels.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            report.error("Tape with label #{label} is not in the database.")
            next
        end
        count = db.get_first_value("SELECT COUNT (*) FROM links LEFT JOIN tapes ON tapes.number=links.tape_number" +
                                       " WHERE tapes.label=\"#{label}\"")
        if (count == 0)
            db.execute("DELETE FROM tapes WHERE label=\"#{label}\"")
            report.tape_removed(label)
        else
            report.error("Tape with label #{label} is part of a tapeset.")
        end
    end
end

def tape_list(db, report, search_terms)
    query = 'SELECT label FROM tapes'
    unless (search_terms.empty?())
        query += ' WHERE'
        search_terms.each() do |search_term|
            query += " label LIKE \"#{search_term}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY label ASC'
    tapes = db.execute(query)
    tapes.collect!() do |tape|
        {:label => tape[0]}
    end
    report.table(tapes, [:label])
end

def tape_info(db, report, labels, verbose)
    query = 'SELECT DISTINCT tapes.number, tapes.label, tapes.size, tapes.tapeset_idx, tapes.written, tapes.verified,' +
        ' tapes.ts_files, tapes.ts_size, tapes.tape_files, tapes.tape_size, tapes.tar_size, tapesets.name FROM tapes' +
        ' LEFT JOIN links ON links.tape_number=tapes.number LEFT JOIN tapesets ON tapesets.number=links.tapeset_number'
    unless (labels.empty?())
        query += ' WHERE'
        labels.each() do |label|
            query += " label=\"#{label}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY tapes.label ASC'

    tapes = db.execute(query)
    tapes.collect!() do |tape|
        capacity = tape[2] / 1000000000
        if (tape[10].nil?())
            used = nil
        else
            used = "#{((tape[10].to_f() / tape[2].to_f()) * 100.0).round(1)} %"
        end
        if ((tape[7].nil?()) || (tape[10].nil?()))
            overhead = nil
        else
            overhead = tape[10] - tape[9]
        end

        w = tape[4].nil? ? nil : Time.at(tape[4])
        v = tape[5].nil? ? nil : Time.at(tape[5])

        {:label => tape[1], :tapeset => tape[11], :ts_idx => tape[3], :capacity => "#{capacity} GB", 
            :used => used, :files => tape[6], :size => tape[7], :tape_files => tape[8], 
            :tape_size => tape[9], :tar_size => tape[10], :overhead => overhead, :written => w, :verified => v}
    end
    if (verbose)
        report.table(tapes, [:label, :capacity, :used, :tapeset, :ts_idx, :files, :size, :tape_files, :tape_size, 
            :tar_size, :overhead, :written, :verified])
    else
        report.table(tapes, [:label, :capacity, :used, :tapeset, :ts_idx, :written, :verified])
    end
end

def tape_manifest(db, report, label)
    report.msg("Manifest for tape with label #{label}:")
    files = db.execute("SELECT path, sha1 FROM files LEFT JOIN links ON links.file_number=files.number LEFT" +
                           " JOIN tapes ON tapes.number=links.tape_number WHERE tapes.label=\"#{label}\" ORDER" +
                           " BY files.path ASC")
    files.each() do |file|
        report.always("#{file[1]}  #{file[0]}")
    end
end

def tape_mark_erased(db, report, labels)
    query = "UPDATE tapes SET written=NULL, verified=NULL, tape_files=NULL, tape_size=NULL, tar_size=NULL WHERE"
    labels.each() do |label|
        query += " label=\"#{label}\" OR"
    end
    query.chomp!(' OR')
    db.execute(query)
    labels.each() do |label|
        report.tape_updated(label)
    end
end

def tape_mark_written(db, report, labels)
    labels.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            report.error("Tape with label #{label} is not in the database.")
            next
        end

        in_tapeset = db.get_first_value("SELECT COUNT (*) FROM links LEFT JOIN tapes ON " +
            "links.tape_number=tapes.number WHERE tapes.label=\"#{label}\"")
        if (in_tapeset == 0)
            report.error("Tape with label #{label} is not in a tapeset.")
            next
        end

        now = Time.new().to_i()
        db.execute("UPDATE tapes SET written=#{now} WHERE label=\"#{label}\"")
        report.tape_updated(label)
    end
end

def tape_mark_verified(db, report, labels)
    labels.each() do |label|
        in_db = db.get_first_value("SELECT COUNT(*) FROM tapes WHERE label=\"#{label}\"")
        if (in_db == 0)
            report.error("Tape with label #{label} is not in the database.")
            next
        end

        in_tapeset = db.get_first_value("SELECT COUNT (*) FROM links LEFT JOIN tapes ON " +
            "links.tape_number=tapes.number WHERE tapes.label=\"#{label}\"")
        if (in_tapeset == 0)
            report.error("Tape with label #{label} is not in a tapeset.")
            next
        end

        is_written = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{label}\" AND written IS NOT NULL")
        if (is_written == 0)
            report.error("Tape with label #{label} cannot be verified before it is written.")
            next
        end

        now = Time.new().to_i()
        db.execute("UPDATE tapes SET verified=#{now} WHERE label=\"#{label}\"")
        report.tape_updated(label)
    end
end

def tape_erase(db, report, rewind, offline, simulate, label, device)
    report.msg('Erasing tape.')
    unless (simulate)
        output = `mt-st -f #{device} erase`
        unless (output == '')
            report.error("Mt-st error: #{output}")
            return false
        end
    end

    db.execute("UPDATE tapes SET tape_files=NULL, tape_size=NULL, tar_size=NULL WHERE label=\"#{label}\"")

    tape_mark_erased(db, report, [label])

    return false if (rewind && (not tape_rewind(report, device, simulate)))
    return false if (offline && (not tape_offline(report, device, simulate)))
end

def tape_write(db, report, rewind, offline, compression, simulate, label, device)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{label}\"")
    if (in_db == 0)
        report.error("Tape with label #{label} is not in the database.")
        return false
    end

    files = db.execute("SELECT path, sha1, mtime, on_disk, files.size FROM files LEFT JOIN links ON " +
        "links.file_number=files.number LEFT JOIN tapes ON tapes.number=links.tape_number WHERE " +
        "tapes.label=\"#{label}\"")
    
    return false unless (tape_set_block_size(report, device, 8192 * 512, simulate))
    return false unless (tape_set_compression(report, device, compression, simulate))

    t_start = Time.now()
    report.time("Started writing tape", t_start)

    ok = tar_write(db, report, files, device, label, simulate)
    return false unless (ok)

    tape_mark_written(db, report, [label])

    return false if (rewind && (not tape_rewind(report, device, simulate)))
    return false if (offline && (not tape_offline(report, device, simulate)))

    t_end = Time.now()
    report.duration("Finished writing tape", t_start, t_end)

    return true
end

def tape_verify(db, report, rewind, offline, simulate, label, device)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{label}\"")
    if (in_db == 0)
        report.error("Tape with label #{label} is not in the database.")
        return false
    end

    return false unless (tape_set_block_size(report, device, 8192 * 512, simulate))

    t_start = Time.now()
    report.time("Started verifying tape", t_start)

    unless (simulate)
        return false unless (tar_verify(report, device))
    end

    tape_mark_verified(db, report, [label])

    return false if (rewind && (not tape_rewind(report, device, simulate)))
    return false if (offline && (not tape_offline(report, device, simulate)))

    t_end = Time.now()
    report.duration("Finished verifying tape", t_start, t_end)

    return true
end

def tape_write_verify(db, report, rewind, offline, compression, simulate, label, device)
    return false unless (tape_write(db, report, rewind, offline, compression, simulate, label, device))
    return false unless (tape_verify(db, report, rewind, offline, simulate, label, device))
    return true
end

def tape_replace(db, report, old_name, new_name)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{new_name}\"")
    if (in_db == 0)
        db.execute("UPDATE tapes SET label=\"#{new_name}\", written=NULL, verified=NULL, tape_files=NULL, " +
            "tape_size=NULL, tar_size=NULL WHERE label=\"#{old_name}\"")
        report.tape_updated(old_name)
    else
        report.error("Cannot rename #{old_name} to #{new_name}, #{new_name} exists in the database.")
    end
end

def tape_stage(db, report, label, path)
    if (not (File.directory?(path) && File.writable?(path)))
        report.error("Path #{path} is not a directory or not writable.")
        return false
    end

    in_db = db.get_first_value("SELECT COUNT (*) FROM tapes WHERE label=\"#{label}\"")
    if (in_db == 0)
        report.error("Tape with label #{label} is not in the database.")
        return false
    end

    files = db.execute("SELECT path, sha1, mtime, on_disk, files.size FROM files LEFT JOIN links ON " +
        "links.file_number=files.number LEFT JOIN tapes ON tapes.number=links.tape_number WHERE " +
        "tapes.label=\"#{label}\"")
    
    tar_file = "#{path}/#{label}.tar"

    t_start = Time.now()
    report.time("Started staging tape", t_start)

    ok = tar_write(db, report, files, tar_file, label)
    report.tape_updated(label)

    t_end = Time.now()
    report.duration("Finished staging tape", t_start, t_end)

    return ok
end

#-----------------------------------------------------------------------------------------------------------------------
# Tapeset method section

def tapeset_add(db, report, verbose, quiet, double, triple, ffd, no_tape_level, name, paths)
    sets = triple ? 3 : double ? 2 : 1

    # 1. Assemble the tapeset names.
    tapeset_names = []
    if (not (double || triple))
        tapeset_names << name
    else
        for set in 0..(sets - 1)
            case set
            when 0
                suffix = ' (primary)'
            when 1
                suffix = ' (secondary)'
            when 2
                suffix = ' (tertiary)'
            end
            tapeset_names << (name + suffix)
        end
    end
    tapeset_names.each() do |n|
        # Check if the name already exists in the tapesets table.
        c = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{n}\"")
        if (c > 0)
            report.error("Tapeset with name #{n} already exists in database.")
            return
        end
    end

    # 2. File selection.
    files = nil
    query = 'SELECT * FROM files WHERE ('
    paths.each() do |item|
        query += "path LIKE \"#{item}%\" OR "
    end
    query.chomp!(' OR ')
    query += ') AND (on_disk=1)'
    if (ffd)
        query += ' ORDER BY size DESC'
    else
        query += ' ORDER BY path ASC'
    end
    files = db.execute(query)
    if (files.length() == 0)
        report.error("No files matched the selection criteria.")
        return
    end

    # 3. Bin packing.
    accumulator = 0
    files.each() do |file|
        accumulator += file[2]
        accumulator += (3 * 512) # Tar header overhead.
    end
    average_size = accumulator / files.length()

    # TODO: This is bad, find a way to deal with tapes of different sizes.
    first_tape_size = db.get_first_value('SELECT size FROM tapes')

    # Reduce tape size with 5% to make room for overheads.
    first_tape_size = (0.95 * first_tape_size).to_i()

    # Get smallest integer number of tapes that will fit the data.
    tapes_needed = (accumulator.to_f() / first_tape_size).ceil()

    # Determine bytes per tape.
    if (no_tape_level)
        bytes_per_tape = first_tape_size
    else
        # Add the average file size here to give the bin packing algorithm some wriggle room.
        bytes_per_tape = (accumulator / tapes_needed) + average_size
    end

    # Prepare.
    tape_contents = []
    tape_bytes_left = []
    tape_bytes = []
    for i in 0..(tapes_needed - 1)
        tape_contents[i] = []
        tape_bytes_left[i] = bytes_per_tape
        tape_bytes[i] = 0
    end

    # Actual bin packing of files.
    file_count = files.length()
    for i in 0..(file_count - 1)
        overhead = (512 * 3) + (512 - (files[i][2] % 512))
        file_size = (files[i][2])

        stored = false
        for j in 0..(tapes_needed - 1)
            if (tape_bytes_left[j] > (file_size + overhead + 1024)) # Add 1024 bytes for the tarball footer.
                tape_contents[j] << files[i]
                tape_bytes_left[j] -= (file_size + overhead)
                tape_bytes[j] += file_size
                stored = true
                break
            end
        end
        unless (stored)
            report.error("Failed to store file #{files[i][4]} (#{files[i][2]} bytes). All tapes are full.")
            return
        end
    end

    # 4. Check if enough tapes are available.
    free_tapes = db.execute('SELECT * FROM tapes WHERE tapeset_idx=-1 ORDER BY label ASC')
    tapes_required = tapes_needed * sets
    if (free_tapes.length() < tapes_required)
        report.error("Insufficient free tapes. Available: #{free_tapes.length()} Required: #{tapes_required}")
        return
    end

    # 5. Create tapesets in database.
    tape_index = 0
    tapes_used = []
    for set in 0..(sets - 1)
        now = Time.now()
        db.execute("INSERT INTO tapesets (name, tape_count, created) VALUES (\"#{tapeset_names[set]}\", " +
            "#{tapes_needed}, #{now.to_i()})")
        report.tapeset_added(tapeset_names[set])
        set_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset_names[set]}\"")

        for tape in 0..(tapes_needed - 1)
            tape_index_in_set = tape_index % tapes_needed
            db.execute("UPDATE tapes SET tapeset_idx=#{tape_index_in_set}, " +
                "ts_files=#{tape_contents[tape_index_in_set].length()}, " + 
                "ts_size=#{tape_bytes[tape_index_in_set]} WHERE label=\"#{free_tapes[tape_index][1]}\"")
            report.tape_updated(free_tapes[tape_index][1])

            tape_contents[tape_index_in_set].each() do |file|
                db.execute("INSERT INTO links (file_number, tape_number, tapeset_number) VALUES (#{file[0]}," +
                    " #{free_tapes[tape_index][0]}, #{set_number})")
                report.link_added(file[4], free_tapes[tape_index][1], tapeset_names[set])
            end

            tapes_used << free_tapes[tape_index][1]

            tape_index += 1
        end

        paths.each do |path|
            db.execute("INSERT INTO tapeset_paths (tapeset_number, path) VALUES (#{set_number}, \"#{path}\")")
            # TODO: Add creation report.
        end
    end

    # 6. List info about new used tapes.
    report.info('Tapeset(s) created:')
    tape_info(db, report, tapes_used, verbose) unless (quiet)
end

def tapeset_append(db, report, verbose, quiet, ffd, no_tape_level, name)
    # 1. Check if tapeset exists
    count = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{name}\"")
    if (count == 0) 
        report.error("Tapeset with name: #{name} does not exist.")
        return
    end

    # 2. Collect paths in the tapeset and the files to append to the tapeset.
    tapeset_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{name}\"")
    paths = db.execute("SELECT path FROM tapeset_paths WHERE tapeset_number=#{tapeset_number}")
    paths.flatten!()

    files = nil
    query = 'SELECT * FROM files WHERE ('
    paths.each() do |item|
        query += "path LIKE \"#{item}%\" OR "
    end
    query.chomp!(' OR ')
    query += ") AND (on_disk=1) AND (number NOT IN (SELECT file_number FROM links WHERE tapeset_number=#{tapeset_number}))"
    if (ffd)
        query += ' ORDER BY size DESC'
    else
        query += ' ORDER BY path ASC'
    end
    files = db.execute(query)
    if (files.length() == 0)
        report.error("No files matched the selection criteria.")
        return
    end

    # 3. Bin packing.
    accumulator = 0
    files.each() do |file|
        accumulator += file[2]
        accumulator += (3 * 512) # Tar header overhead.
    end
    average_size = accumulator / files.length()

    # TODO: This is bad, find a way to deal with tapes of different sizes.
    first_tape_size = db.get_first_value('SELECT size FROM tapes')

    # Reduce tape size with 5% to make room for overheads.
    first_tape_size = (0.95 * first_tape_size).to_i()

    # Get smallest integer number of tapes that will fit the data.
    tapes_needed = (accumulator.to_f() / first_tape_size).ceil()

    # Determine bytes per tape.
    if (no_tape_level)
        bytes_per_tape = first_tape_size
    else
        # Add the average file size here to give the bin packing algorithm some wriggle room.
        bytes_per_tape = (accumulator / tapes_needed) + average_size
    end

    # Prepare.
    tape_contents = []
    tape_bytes_left = []
    tape_bytes = []
    for i in 0..(tapes_needed - 1)
        tape_contents[i] = []
        tape_bytes_left[i] = bytes_per_tape
        tape_bytes[i] = 0
    end

    # Actual bin packing of files.
    file_count = files.length()
    for i in 0..(file_count - 1)
        overhead = (512 * 3) + (512 - (files[i][2] % 512))
        file_size = (files[i][2])

        stored = false
        for j in 0..(tapes_needed - 1)
            if (tape_bytes_left[j] > (file_size + overhead + 1024)) # Add 1024 bytes for the tarball footer.
                tape_contents[j] << files[i]
                tape_bytes_left[j] -= (file_size + overhead)
                tape_bytes[j] += file_size
                stored = true
                break
            end
        end
        unless (stored)
            report.error("Failed to store file #{files[i][4]} (#{files[i][2]} bytes). All tapes are full.")
            return
        end
    end
    
    # 4. Check if enough tapes are available.
    free_tapes = db.execute('SELECT * FROM tapes WHERE tapeset_idx=-1 ORDER BY label ASC')
    if (free_tapes.length() < tapes_needed)
        report.error("Insufficient free tapes. Available: #{free_tapes.length()} Required: #{tapes_needed}")
        return
    end

    # 5. Add tapes to tapeset.
    tape_index = 0
    tapes_used = []

    tapes_in_set = db.get_first_value("SELECT tape_count FROM tapesets WHERE number=#{tapeset_number}")
    db.execute("UPDATE tapesets SET tape_count=#{tapes_in_set + tapes_needed} WHERE number=#{tapeset_number}")

    for tape in 0..(tapes_needed - 1)
        tape_index = tapes_in_set + tape
        db.execute("UPDATE tapes SET tapeset_idx=#{tape_index}, " +
            "ts_files=#{tape_contents[tape].length()}, " + 
            "ts_size=#{tape_bytes[tape]} WHERE label=\"#{free_tapes[tape][1]}\"")
        report.tape_updated(free_tapes[tape][1])

        tape_contents[tape].each() do |file|
            db.execute("INSERT INTO links (file_number, tape_number, tapeset_number) VALUES (#{file[0]}," +
                " #{free_tapes[tape][0]}, #{tapeset_number})")
            report.link_added(file[4], free_tapes[tape][1], name)
        end

        tapes_used << free_tapes[tape][1]
    end

    # 6. List info about new used tapes.
    report.info('Tapeset updated:')
    tape_info(db, report, tapes_used, verbose) unless (quiet)
end

def tapeset_remove(db, report, names)
    names.each() do |tapeset|
        # First, collect all the information.
        tapeset_number = db.get_first_value("SELECT number FROM tapesets WHERE name=\"#{tapeset}\"")

        tapes = db.execute("SELECT DISTINCT links.tape_number, tapes.label FROM links LEFT JOIN tapes ON" +
            " tapes.number=links.tape_number WHERE tapeset_number=#{tapeset_number}")

        files_check = db.execute("SELECT links.file_number, files.path FROM links LEFT JOIN files ON" +
            " files.number=links.file_number WHERE links.tapeset_number=#{tapeset_number} AND files.on_disk=0")
        files_remove = []
        files_check.each() do |file|
            tapeset_count = db.get_first_value("SELECT COUNT(DISTINCT tapeset_number) FROM links WHERE" +
                " file_number=#{file[0]} AND NOT tapeset_number=#{tapeset_number}")
            if (tapeset_count == 0)
                files_remove << file
            end
        end

        links = db.execute("SELECT files.path, tapes.label, tapesets.name FROM links LEFT JOIN files ON" +
            " files.number=links.file_number LEFT JOIN tapes ON tapes.number=links.tape_number LEFT JOIN tapesets" +
            " ON tapesets.number=links.tapeset_number WHERE links.tapeset_number=#{tapeset_number}")

        # Now make the database updates.
        # 1. Delete the tapeset.
        db.execute("DELETE FROM tapesets WHERE number=#{tapeset_number}")
        report.tapeset_removed(tapeset)
        # 2. Delete the tapeset paths.
        db.execute("DELETE FROM tapeset_paths WHERE tapeset_number=#{tapeset_number}")
        # TODO: Add delete report.
        # 3. Update tapes.
        tapes.each() do |tape|
            db.execute("UPDATE tapes SET tapeset_idx=-1, written=NULL, verified=NULL, ts_files=NULL, ts_size=NULL, " +
                "tape_files=NULL, tape_size=NULL, tar_size=NULL WHERE number=#{tape[0]}")
            report.tape_updated(tape[1])
        end
        # 4. Remove files.
        files_remove.each() do |file|
            db.execute("DELETE FROM files WHERE number=#{file[0]}")
            report.file_removed(file[1])
        end
        # 5. Remove links.
        db.execute("DELETE FROM links WHERE tapeset_number=#{tapeset_number}")
        links.each() do |link|
            report.link_removed(link[0], link[1], link[2])
        end
    end
end

def tapeset_rename(db, report, old_name, new_name)
    in_db = db.get_first_value("SELECT COUNT (*) FROM tapesets WHERE name=\"#{new_name}\"")
    if (in_db == 0)
        db.execute("UPDATE tapesets SET name=\"#{new_name}\" WHERE name=\"#{old_name}\"")
        report.tapeset_updated(old_name)
    else
        report.error("Tapeset with name #{new_name} already exists in the database.")
    end
end

def tapeset_list(db, report, search_terms)
    query = 'SELECT name FROM tapesets'
    unless (search_terms.empty?())
        query += ' WHERE'
        search_terms.each() do |search_term|
            query += " name LIKE \"#{search_term}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY name ASC'
    tapesets = db.execute(query)
    tapesets.collect!() do |tapeset|
        {:name => tapeset[0]}
    end
    report.table(tapesets, [:name])
end

def tapeset_info(db, report, names)
    query = 'SELECT DISTINCT tapesets.name, tapesets.tape_count, tapes.label, tapes.tapeset_idx, tapesets.created ' +
        'FROM tapesets LEFT JOIN links ON links.tapeset_number=tapesets.number LEFT JOIN tapes ON ' +
        'tapes.number=links.tape_number'
    unless (names.empty?())
        query += ' WHERE'
        names.each() do |name|
            query += " name=\"#{name}\" OR"
        end
        query.chomp!(' OR')
    end
    query += ' ORDER BY tapes.label ASC'

    data = db.execute(query)
    data.collect!() do |row|
        c = row[4].nil?() ? nil : Time.at(row[4])
        {:name => row[0], :tape => row[2], :volume => "#{(row[3] + 1)} / #{row[1]}", :created => c}
    end
    report.table(data, [:name, :tape, :volume, :created])
end

#-----------------------------------------------------------------------------------------------------------------------
# Tar method section

def tar_write(db, report, files, output, label, simulate)
    begin
        # Open manifest and filelist.
        manifest = File.open('manifest.txt', 'wb')
        filelist = File.open('filelist.txt', 'wb')

        write_size = 0
        write_files = []
        files.each() do |file|
            if (file[3] == 0)
                report.warning("File #{file[0]} is excluded because it is marked as not on disk.")
                next
            end
    
            unless (File.file?(file[0]))
                report.warning("File #{file[0]} is excluded because it has been deleted.")
                next
            end
    
            if (File.mtime(file[0]).to_i() != file[2])
                report.warning("File #{file[0]} is excluded because its mtime does not match the database.")
                next
            end
    
            relative_filename = file[0].sub(/^\//, '')

            filelist.puts(relative_filename)
            manifest.puts("#{file[1]}  #{relative_filename}")

            write_files << file
            write_size += file[4]
        end

        manifest.close()
        filelist.close()

        unless (simulate)
            result = `tar -H pax -b 8192 -cf #{output} manifest.txt -C / -T filelist.txt --totals 2>&1`
            unless($?.success?())
                report.error("Tar process returned with error status. Result:\n#{result}")
                return false, nil
            end

            written = result.match(/[0-9]+/).to_s().to_i()
        else
            written = write_size
        end

        db.execute("UPDATE tapes SET tape_files=#{write_files.length()}, tape_size=#{write_size}, " +
            "tar_size=#{written} WHERE label=\"#{label}\"")

        return true
    rescue IOError => e
        report.error("IOError: #{e.to_s()}")
        return false, nil
    ensure
        manifest.close() unless (manifest.nil?())
        filelist.close() unless (filelist.nil?())
        File.delete('manifest.txt')
        File.delete('filelist.txt')
    end
end

def tar_block_header_checksum_valid?(block)
    bytes = block.unpack('C512')
    cksum_bytes = []
    for i in 0..7
        cksum_bytes << bytes[i + 148]
        bytes[i + 148] = 32
    end
    cksum_in_block = cksum_bytes.pack('C6').to_i(8)
    cksum_calc = 0
    bytes.each() do |byte|
        cksum_calc += byte
    end
    return cksum_calc == cksum_in_block
end

def tar_block_header_parse(block)
    return {
        :name => block[0..99].strip!(),
        :mode => block[100..107].strip!(),
        :uid => block[108..115].strip!(),
        :gid => block[116..123].strip!(),
        :size => block[124..135].strip!().to_i(8),
        :mtime => block[136..147].strip!().to_i(8),
        :checksum => block[148..155].strip!().to_i(8),
        :link => block[156],
        :link_name => block[157..256].strip!(),
        :ustar => block[257..262].strip!(),
        :ustar_version => block[263..264].to_i(8),
        :owner_user => block[265..296].strip!(),
        :owner_group => block[297..328].strip!(),
        :dev_major_num => block[329..336].strip!().to_i(8),
        :dev_minor_num => block[337..344].strip!().to_i(8),
        :name_prefix => block[345..499].strip!()
    }
end

def tar_verify(report, input)
    macro_block_size = 8192 * 512
    verified = 0
    incorrect = 0

    begin
        stream = File.open(input, 'rb')

        state = :scan
        ext_header = nil
        ext_header_data = ''
        ext_header_file_size = nil
        header = nil
        processed = 0
        digest = nil
        read_manifest = false
        filename = ''
        hashes = {}

        while(true)
            macro_block = stream.read(macro_block_size)
            break if (macro_block.nil?())

            case macro_block.length()
            when macro_block_size
                left = macro_block_size
                offset = 0
                while (left > 0)
                    block = macro_block[offset..(offset + 511)]

                    case state
                    when :scan
                        if (tar_block_header_checksum_valid?(block))
                            x = tar_block_header_parse(block)
                            if (x[:link] == 'x') # PAX extended header.
                                ext_header = x
                                ext_header_file_size = nil
                                processed = 0
                                state = :ext
                            elsif (x[:link] == '0') # USTAR file header.
                                header = x

                                filename = ''
                                filename += header[:prefix].to_s() unless (header[:prefix].nil?())
                                filename += header[:name] unless (header[:name].nil?())
                                report.msg("Verify file #{filename}")

                                if (filename == 'manifest.txt')
                                    read_manifest = true
                                    manifest = ''
                                end

                                header[:size] = ext_header_file_size unless (ext_header_file_size.nil?())
                                processed = 0
                                digest = Digest::SHA1.new()
                                # Handle the special case of 0-length files in the tarball.
                                if (header[:size] == 0)
                                    calc_sha1 = digest.hexdigest()
                                    manifest_sha1 = hashes[filename]
                                    if (manifest_sha1.nil?())
                                        report.error("File #{filename} is not in manifest.")
                                    else
                                        unless (manifest_sha1 == calc_sha1)
                                            report.error("File #{filename} does not match manifest hash.")
                                            incorrect += 1
                                        end
                                    end
    
                                    verified += 1

                                    state = :scan
                                else
                                    state = :file
                                end
                            end
                        end
                    when :ext
                        ext_header_data += block
                        processed += 512
                        if (processed >= ext_header[:size])
                            entries = ext_header_data.strip().split("\n")
                            sha1 = nil
                            entries.each() do |entry|
                                if (entry =~ /[0-9]+ size=[0-9]+/)
                                    numbers = entry.scan(/[0-9]+/)
                                    ext_header_file_size = numbers.last().to_i()
                                end
                            end
                            ext_header_data = ''
                            state = :scan
                        end
                    when :file
                        length = [512, (header[:size] - processed)].min()
                        if (read_manifest)
                            manifest += block[0..(length - 1)]
                        else
                            # If block is here to speedupify the digest. No need to copy bytes if full block is digested.
                            if (length != 512)
                                digest.update(block[0..(length - 1)])
                            else
                                digest.update(block)
                            end
                        end

                        processed += 512
                        if (processed >= header[:size])
                            if (read_manifest)
                                read_manifest = false
                                manifest.split("\n").each() do |line|
                                    data = line.split('  ')
                                    hashes[data[1]] = data[0]
                                end
                            else
                                calc_sha1 = digest.hexdigest()
                                manifest_sha1 = hashes[filename]
                                if (manifest_sha1.nil?())
                                    report.error("File #{filename} is not in manifest.")
                                else
                                    unless (manifest_sha1 == calc_sha1)
                                        report.error("File #{filename} does not match manifest hash.")
                                        incorrect += 1
                                    end
                                end

                                verified += 1
                            end
                            state = :scan
                        end

                    end

                    left -= 512
                    offset += 512
                end
            when 0
                break # At EOF.
            else
                report.error("Truncated tarball.")
                return false
            end
        end

        if (incorrect > 0)
            report.error("Verified #{verified} files, #{incorrect} of which were incorrect.")
        else
            report.info("Verified #{verified} files, all correct.")
        end

        return true
    rescue IOError => e

        return false
    ensure
        stream.close() unless (stream.nil?())
    end
end

#-----------------------------------------------------------------------------------------------------------------------
# Tool method section

def tool_find_arg_short(args, short) # COMMON
    args.each() do |arg|
        return arg if (arg.short() == short)
    end unless (args.nil?())
    return nil
end

def tool_find_arg_long(args, long) # COMMON
    args.each() do |arg|
        return arg if (arg.long() == long)
    end unless (args.nil?())
    return nil
end

def tool_usage_args(action) # COMMON
    args = ''
    unless (action.nil?())
        action.args_type().each() do |arg|
            args += "#{arg.upcase} "
        end
        args.chomp!(' ')
        args += '...' if (action.max_args() == -1)
        args = "<#{args}>" if ((action.min_args() == 0) && (action.max_args() != 0))
    end
    return args
end

def tool_show_usage(report, banner, actions, modifiers, map) # COMMON
    report.always(banner)
    report.always('=' * banner.length)

    all = []
    all << actions
    all << modifiers
    all.flatten!()

    index = 0
    map.each() do |submap|
        report.always(submap[0])
        report.always('-' * submap[0].length())
        submap[1].each() do |subsubmap|
            report.always(subsubmap[0])
            subsubmap[1].times() do ||
                action = all[index]
                args = tool_usage_args(action)
                short = action.short().nil?() ? '' : action.short()
                long = "#{action.long()} #{args}"

                short = short + (' ' * (10 - short.length()))
                long = long + (' ' * (35 - long.length()))
                report.always(short + long + action.help())

                index += 1
            end
        end
    end
end

def tool_parse_command_line(report, actions, modifiers) # COMMON
    selected_actions = []
    selected_modifiers = []

    delete = []
    ARGV.each() do |arg|
        if (arg.match(/^\-[a-zA-Z0-9]{1}$/))
            # Deal with short action or modifier.
            action = tool_find_arg_short(actions, arg)
            modifier = tool_find_arg_short(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
        if (arg.match(/^\-\-[a-zA-Z0-9\-]{2,}$/))
            # Deal with long action or modifier.
            action = tool_find_arg_long(actions, arg)
            modifier = tool_find_arg_long(modifiers, arg)
            if (action.nil?() && modifier.nil?())
                report.error(arg)
                return [], [], []
            else
                selected_actions << action unless (action.nil?())
                selected_modifiers << modifier unless (modifier.nil?())
                delete << arg
            end
        end
    end
    delete.each() do |del|
        ARGV.delete_at(ARGV.index(del))
    end

    return selected_actions, selected_modifiers, ARGV
end

def tool_build_modifiers()
    m = []
    m << Arg.new('--verbose'      , '-v', 0, 0, [], 'Run verbosely.')
    m << Arg.new('--quiet'        , '-q', 0, 0, [], 'Run quietly.')
    m << Arg.new('--sql'          , nil , 0, 0, [], 'Shows SQL queries. Useful for debugging.')
    m << Arg.new('--async'        , nil , 0, 0, [], 'Database in async mode. Unsafe if PC unstable or power cut.')
    m << Arg.new('--simulate'     , '-s', 0, 0, [], 'Simulates the tape operations.')

    m << Arg.new('--rewind'       , nil , 0, 0, [], 'Rewinds tape after write or verify.')
    m << Arg.new('--offline'      , nil , 0, 0, [], 'Offlines (ejects) tape after write or verify.')
    m << Arg.new('--compression'  , nil , 0, 0, [], 'Enables the tape drives hardware compression.')

    m << Arg.new('--double'       , '-2', 0, 0, [], 'Double redundancy for --add-tapeset.')
    m << Arg.new('--triple'       , '-3', 0, 0, [], 'Triple redundancy for --add-tapeset.')
    m << Arg.new('--ffd'          , nil , 0, 0, [], 'First Fit Decreasing bin packing for --add-tapeset.')
    m << Arg.new('--no-tape-level', nil , 0, 0, [], 'Fill tape to max instead of leveling for --add-tapeset.')
    return m
end

def tool_build_actions()
    a = []
    a << Arg.new('--help'           , '-h', 0,  0, []               , 'Displays this help.')

    a << Arg.new('--add-paths'      , nil , 1, -1, [:path]          , 'Adds paths to database.')
    a << Arg.new('--update'         , nil , 1, -1, [:path]          , 'Updates paths in database.')
    a << Arg.new('--remove-paths'   , nil , 1, -1, [:path]          , 'Removes paths from database.')
    a << Arg.new('--prune'          , nil , 1, -1, [:path]          , 'Checks database paths for removed files.')
    a << Arg.new('--check'          , nil , 1, -1, [:path]          , 'Checks database paths for duplicates.')

    a << Arg.new('--add-tapes'      , nil , 1, -1, [:label]         , 'Adds tapes to database.')
    a << Arg.new('--remove-tapes'   , nil , 1, -1, [:label]         , 'Removes tapes from database.')
    a << Arg.new('--list-tapes'     , nil , 0, -1, [:searchterm]    , 'Lists tapes in database.')
    a << Arg.new('--info-tapes'     , nil , 0, -1, [:label]         , 'Shows info about tapes in database.')
    a << Arg.new('--manifest'       , nil , 1,  1, [:label]         , 'Shows the files on a tape.')
    a << Arg.new('--mark-erased'    , nil , 1, -1, [:label]         , 'Marks tapes as erased.')
    a << Arg.new('--mark-written'   , nil , 1, -1, [:label]         , 'Marks tapes as written.')
    a << Arg.new('--mark-verified'  , nil , 1, -1, [:label]         , 'Marks tapes as verified.')
    a << Arg.new('--erase'          , nil , 2,  2, [:label, :device], 'Erases the tape on the device.')
    a << Arg.new('--write'          , nil , 2,  2, [:label, :device], 'Writes the tape on the device.')
    a << Arg.new('--verify'         , nil , 2,  2, [:label, :device], 'Verifies the tape on the device.')
    a << Arg.new('--write-verify'   , nil , 2,  2, [:label, :device], 'Writes and verifies the tape on the device.')
    a << Arg.new('--replace'        , nil , 2,  2, [:label, :label] , 'Replaces the tape in the database.')
    a << Arg.new('--stage'          , nil , 2,  2, [:label, :path]  , 'Stages the tarball in the given path.')

    a << Arg.new('--add-tapeset'    , nil , 2, -1, [:name, :path]   , 'Adds a tapeset to the database.')
    a << Arg.new('--append'         , nil , 1,  1, [:name]          , 'Appends new files to the named tapeset (incremental backup)')
    a << Arg.new('--remove-tapesets', nil , 1, -1, [:name]          , 'Removes tapesets from the database.')
    a << Arg.new('--rename'         , nil , 1,  2, [:name, :name]   , 'Renames a tapeset in the database.')
    a << Arg.new('--list-tapesets'  , nil , 0, -1, [:searchterm]    , 'Lists tapesets in the database.')
    a << Arg.new('--info-tapesets'  , nil , 0, -1, [:name]          , 'Shows info about tapesets in the database.')
    return a
end

def tool_usage(report, actions, modifiers)
    map = []
    map << ['Actions:', [['Misc:', 1], ['Paths:', 5], ['Tapes:', 14], ['Tapesets:', 6]]]
    map << ['Modifiers:', [['Misc:', 5], ['Tapes:', 3], ['Tapesets:', 4]]]

    tool_show_usage(report, 'Usage help:', actions, modifiers, map)
end

def tool_validate_arg(arg, type)
    case type
    when :path
        return File.exists?(arg)
    when :label
        return (arg =~ /[A-Z0-9]{6}[L]{1}[1-8]{1}/) || (arg =~ /[A-Z0-9]{6}M8/)
    when :device
        return File.chardev?(arg) && File.readable?(arg) && File.writable?(arg)
    when :searchterm, :name
        # There is no enforcement on search terms or names.
        return true
    else
        # Incorrect type is never valid.
        return false
    end
end

def tool_split_labels(args)
    new_args = []
    args.each() do |arg|
        new_args << arg.split('*').reject() do |c| c.empty?() end
    end
    new_args.flatten!()
    unless (new_args.nil?())
        new_args.uniq!()
    end
    return new_args
end

def tool_split_modifiers(modifiers)
    verbose = false
    quiet = false
    double = false
    triple = false
    ffd = false
    async = false
    rewind = false
    offline = false
    no_tape_level = false
    sql = false
    compression = false
    simulate = false

    modifiers.each() do |modifier|
        case modifier.long()
        when '--verbose'
            verbose = true
        when '--quiet'
            quiet = true
            verbose = false
        when '--double'
            double = true unless (triple)
        when '--triple'
            double = false
            triple = true
        when '--ffd'
            ffd = true
        when '--async'
            async = true
        when '--rewind'
            rewind = true
        when '--offline'
            offline = true
        when '--no-tape-level'
            no_tape_level = true
        when '--sql'
            sql = true
        when '--compression'
            compression = true
        when '--simulate'
            simulate = true
        end
    end

    return verbose, quiet, double, triple, ffd, async, rewind, offline, no_tape_level, sql, compression, simulate
end

def tool_validate_command_line(report, actions, args)
    if (actions.length() == 0)
        report.error('No valid action(s) specified.')
        return false
    end
    if (actions.length() > 1)
        report.error('Too many actions specified.')
        return false
    end

    action = actions[0]
    min_args = action.min_args()
    max_args = action.max_args()

    if (args.length() < min_args)
        report.error('Not enough args.')
        return false
    end

    if ((max_args != -1) && (args.length() != max_args))
        report.error('Incorrect number of args.')
        return false
    end

    arg_index = 0
    args.length().times() do ||
        arg = args[arg_index]
        types = action.args_type()
        if (arg_index >= types.length())
            type = types.last()
        else
            type = types[arg_index]
        end

        unless (tool_validate_arg(arg, type))
            report.error('Invalid arg: ' + arg)
            return false
        end

        arg_index += 1
    end

    return true
end

#-----------------------------------------------------------------------------------------------------------------------
# Main section

begin
    # Initialize variables
    version = 2
    db_version = 4
    report = Report.new()
    db = nil

    # Prepare for dealing with command line.
    possible_actions = tool_build_actions()
    possible_modifiers = tool_build_modifiers()

    # Process command line and check validity.
    actions, modifiers, args = tool_parse_command_line(report, possible_actions, possible_modifiers)
    args = tool_split_labels(args) unless (args.nil?())
    exit(-1) unless (tool_validate_command_line(report, actions, args))

    verbose, quiet, double, triple, ffd, async, rewind, offline, no_tape_level, sql, compression, simulate = \
        tool_split_modifiers(modifiers)

    report.configure(verbose, quiet)

    # Startup banner.
    report.info("Backuptool (version: #{version}, db_version: #{db_version})".color(CC::CYAN))

    # Initialize the database.
    if (sql)
        db = db_init(report, version, db_version, async, verbose, DbWrapper.new())
    else
        db = db_init(report, version, db_version, async, verbose)
    end

    # Execute selected action.
    action = actions[0].long()
    case action
    when '--help'
        tool_usage(report, possible_actions, possible_modifiers)

    when '--add-paths'
        path_add(db, report, args)
    when '--update'
        path_update(db, report, args)
    when '--remove-paths'
        path_remove(db, report, args)
    when '--prune'
        path_prune(db, report, args)
    when '--check'
        path_check(db, report, args)

    when '--add-tapes'
        tape_add(db, report, args)
    when '--remove-tapes'
        tape_remove(db, report, args)
    when '--list-tapes'
        tape_list(db, report, args)
    when '--info-tapes'
        tape_info(db, report, args, verbose)
    when '--manifest'
        tape_manifest(db, report, args[0])
    when '--mark-erased'
        tape_mark_erased(db, report, args)
    when '--mark-written'
        tape_mark_written(db, report, args)
    when '--mark-verified'
        tape_mark_verified(db, report, args)
    when '--erase'
        tape_erase(db, report, rewind, offline, simulate, args[0], args[1])
    when '--write'
        tape_write(db, report, rewind, offline, compression, simulate, args[0], args[1])
    when '--verify'
        tape_verify(db, report, rewind, offline, simulate, args[0], args[1])
    when '--write-verify'
        tape_write_verify(db, report, rewind, offline, compression, simulate, args[0], args[1])
    when '--replace'
        tape_replace(db, report, args[0], args[1])
    when '--stage'
        tape_stage(db, report, args[0], args[1])

    when '--add-tapeset'
        tapeset_add(db, report, verbose, quiet, double, triple, ffd, no_tape_level, args[0], \
            args[1..(args.length() -1)])
    when '--append'
        tapeset_append(db, report, verbose, quiet, ffd, no_tape_level, args[0])
    when '--remove-tapesets'
        tapeset_remove(db, report, args)
    when '--rename'
        tapeset_rename(db, report, args[0], args[1])
    when '--list-tapesets'
        tapeset_list(db, report, args)
    when '--info-tapesets'
        tapeset_info(db, report, args)
    else
        report.error('Bug in tool_validate_command_line, should never be able to enter here.')
    end

    # Final report.
    report.finalize()
rescue SQLite3::Exception => exception
    report.error('SQL exception: ' + exception.to_s())
ensure
    db.close() if (db)
end
